<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>力扣&lt;py&gt;</title>
    <link href="/2023/06/04/%E5%8A%9B%E6%89%A3-py/"/>
    <url>/2023/06/04/%E5%8A%9B%E6%89%A3-py/</url>
    
    <content type="html"><![CDATA[<h2 id="977有序数的平方"><a href="#977有序数的平方" class="headerlink" title="977有序数的平方"></a><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">977有序数的平方</a></h2><ol><li><p>使用python推导式+内置sort函数<br>表达式:<strong>[表达式 for 变量 in 列表]</strong> or <strong>[表达式 for 变量 in 列表 条件]</strong> 使用推导式计算平方后的数据，再调用sort()方法完成排序</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sortedSquares</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        res=[num**<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums]<br>        res.sort()<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure></li><li><p>采用快排超出时间限制  </p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Partion</span>(<span class="hljs-params">self,res,low,high</span>):<br>    i=(low - <span class="hljs-number">1</span>)<br>    pivot=res[high]<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(low,high):<br>        <span class="hljs-keyword">if</span> res[j]&lt;=pivot:<br>            i=i+<span class="hljs-number">1</span><br>            res[i],res[j]=res[j],res[i] <span class="hljs-comment"># 小于pivot的往后移动</span><br>    res[i+<span class="hljs-number">1</span>],res[high]=res[high],res[i+<span class="hljs-number">1</span>] <span class="hljs-comment">#把pivot放入合适位置</span><br>    <span class="hljs-keyword">return</span> (i+<span class="hljs-number">1</span>)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Qsort</span>(<span class="hljs-params">self,res,low,high</span>):<br>    <span class="hljs-keyword">if</span> low &lt;high :<br>        pi = self.Partion(res,low,high)<br>        self.Qsort(res,low,pi-<span class="hljs-number">1</span>)<br>        self.Qsort(res,pi+<span class="hljs-number">1</span>,high)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sortedSquares</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>    res=[num**<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums]<br>    self.Qsort(res,<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure></li><li><p>双指针<br> 采用双指针，left和right。先建立一个新的数组其值是nums数组平方后的，然后left指向第一个，right指向最后一个，在定义s为新指针，从当left&lt;&#x3D;right时，双向遍历，并将其值大的一个放入原数组nums的最后，当一次遍历完时，nums数组也完成了从小到大的排序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br> <span class="hljs-keyword">def</span> <span class="hljs-title function_">sortedSquares</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>     res=[num**<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums]<br>     left=<span class="hljs-number">0</span><br>     right=<span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span><br>     s=right <span class="hljs-comment">#s是新指针，从后往前排</span><br>     <span class="hljs-comment"># 大的往后排</span><br>     <span class="hljs-keyword">while</span> left&lt;=right:<br>         <span class="hljs-keyword">if</span> res[left]&lt;=res[right]:<br>             nums[s]=res[right]<br>             s-=<span class="hljs-number">1</span><br>             right-=<span class="hljs-number">1</span><br>         <span class="hljs-keyword">else</span>:<br>             nums[s]=res[left]<br>             s-=<span class="hljs-number">1</span><br>             left+=<span class="hljs-number">1</span><br>     <span class="hljs-keyword">return</span> nums<br></code></pre></td></tr></table></figure></li></ol><h2 id="27移除元素"><a href="#27移除元素" class="headerlink" title="27移除元素"></a><a href="https://leetcode.cn/problems/remove-element/description/">27移除元素</a></h2><ol><li><p>一次遍历把不等于val的值放入数组中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br> <span class="hljs-keyword">def</span> <span class="hljs-title function_">removeElement</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>     <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">len</span>(nums)==<span class="hljs-number">0</span>):<br>         <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>     s=<span class="hljs-number">0</span> <span class="hljs-comment"># s的值代表数组的下标</span><br>     <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(nums)):<br>         <span class="hljs-keyword">if</span> (nums[f]!=val):<br>             nums[s]=nums[f]<br>             s+=<span class="hljs-number">1</span><br>     <span class="hljs-keyword">return</span> s<br></code></pre></td></tr></table></figure></li></ol><h2 id="59-螺旋矩阵"><a href="#59-螺旋矩阵" class="headerlink" title="59.螺旋矩阵||"></a><a href="https://leetcode.cn/problems/spiral-matrix-ii/description/">59.螺旋矩阵||</a></h2><ol><li><p>采用四个循环每次循环解决一个方向<br> 初始化数组后先从左边开始解决，矩阵是n*n的大小，将矩阵第一个默认设置为1，设置一个变量cnt&#x3D;2，从第二个开始依次填充，当下一位位置未被填充时填充cnt，当左边达到边界并且下一个是未被填充时，开始像下填充，同理，当向下填充达到边界且下一个未被填充后向左，再向上，当cnt&#x3D;&#x3D;n^2时完成螺旋矩阵</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">generateMatrix</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>    nums = [[<span class="hljs-number">0</span>] * n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)] <span class="hljs-comment"># 初始化数组 n行n列</span><br>    i=<span class="hljs-number">0</span><br>    j=<span class="hljs-number">0</span><br>    cnt = <span class="hljs-number">2</span><br>    nums[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> cnt &lt;= n*n:<br>        <span class="hljs-comment"># left</span><br>        <span class="hljs-keyword">while</span> j&lt;n-<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> nums[i][j+<span class="hljs-number">1</span>]==<span class="hljs-number">0</span>:<br>            j +=<span class="hljs-number">1</span><br>            nums[i][j]=cnt<br>            cnt +=<span class="hljs-number">1</span><br>        <span class="hljs-comment"># down</span><br>        <span class="hljs-keyword">while</span> i&lt;n-<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> nums[i+<span class="hljs-number">1</span>][j]==<span class="hljs-number">0</span>:<br>            i+=<span class="hljs-number">1</span><br>            nums[i][j]=cnt<br>            cnt+=<span class="hljs-number">1</span><br>        <span class="hljs-comment"># left</span><br>        <span class="hljs-keyword">while</span> j&gt;<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nums[i][j-<span class="hljs-number">1</span>]==<span class="hljs-number">0</span>:<br>            j-=<span class="hljs-number">1</span><br>            nums[i][j]=cnt<br>            cnt +=<span class="hljs-number">1</span><br>        <span class="hljs-comment"># up</span><br>        <span class="hljs-keyword">while</span> i&gt;<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nums[i-<span class="hljs-number">1</span>][j]==<span class="hljs-number">0</span>:<br>            i-=<span class="hljs-number">1</span><br>            nums[i][j]=cnt<br>            cnt +=<span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> nums<br></code></pre></td></tr></table></figure></li></ol><h2 id="34-在排序数组中寻找元素的第一个和最后一个位置"><a href="#34-在排序数组中寻找元素的第一个和最后一个位置" class="headerlink" title="34.在排序数组中寻找元素的第一个和最后一个位置"></a><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/">34.在排序数组中寻找元素的第一个和最后一个位置</a></h2><ol><li><p>类二分查找<br>类似于二分查找，找到第一个等于target的位置，记录后，再继续找到大于target的第一个位置记录，则这区间为所求，关键在于:边界控制条件。<br>由于边界控制不好，导致代码无法运行，看了评论区代码后，依照写了两个函数searchleft和searchright分别查找左边界和有边界；后面看到另一位大神的代码后，发现可以更加简洁，只需一个函数searchleft找到左边界后，右边界依旧使用searchleft，查找值为target+1找到后再将结果-1这样就找到了target的右边界，非常巧妙！ </p><pre><code class="python">class Solution:def searchRange(self, nums: List[int], target: int) -&gt; List[int]:    # 找到左边界    def SearchLeft(nums,target):        low=0        high=len(nums)-1        while low&lt;=high:            mid = (low+high)//2            # 判断条件必须加等号，防止漏掉元素            if nums[mid]&gt;=target:                high=mid-1            else:                low=mid+1        return low    # 找右边界    # def SearchRight(nums,target):    #     low=0    #     high=len(nums)-1    #     while low&lt;=high:    #         mid = (low+high)//2    #         if nums[mid]&gt;target:    #             high=mid-1    #         else:    #             low=mid+1    #     return high    # leftindex=SearchLeft(nums,target)    # rightindex=SearchRight(nums,target)    # searchleft找到的是第一个&gt;target+1的数，数组是有序的；-1后即为target的右边界值    leftindex=SearchLeft(nums,target)    rightindex = SearchLeft(nums,target+1)-1    if leftindex&lt;=rightindex:        return [leftindex,rightindex]    else:        return [-1,-1]</code></pre></li></ol>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MarkDown语法</title>
    <link href="/2023/06/04/MarkDown%E8%AF%AD%E6%B3%95/"/>
    <url>/2023/06/04/MarkDown%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><h3 id="这是三级标题"><a href="#这是三级标题" class="headerlink" title="这是三级标题"></a>这是三级标题</h3><p>换行的话在末尾打两个空格然后回车<br>就能换行</p><p><em>斜文字</em> ctrl+i<br><strong>文字加粗</strong> ctrl+b  </p><p>插入图片直接复制进来就可以  </p><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><table><thead><tr><th>大明</th><th align="center">小明</th><th>小红</th></tr></thead><tbody><tr><td>101</td><td align="center">21</td><td>23</td></tr><tr><td>冒号在哪边就往哪边对齐</td><td align="center"></td><td></td></tr></tbody></table><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>这是一个<a href="https://www.bilibili.com/video/BV1si4y1472o/?spm_id_from=333.337.search-card.all.click&vd_source=08a72620e8d0c24fe640a87de2886b2c">链接</a></p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br></code></pre></td></tr></table></figure><ul><li>实心点</li></ul>]]></content>
    
    
    <categories>
      
      <category>MarkDown</category>
      
    </categories>
    
    
    <tags>
      
      <tag>语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python随笔</title>
    <link href="/2023/06/03/Python%E9%9A%8F%E7%AC%94/"/>
    <url>/2023/06/03/Python%E9%9A%8F%E7%AC%94/</url>
    
    <content type="html"><![CDATA[<h2 id="Python的一些不熟悉的知识"><a href="#Python的一些不熟悉的知识" class="headerlink" title="Python的一些不熟悉的知识"></a>Python的一些不熟悉的知识</h2><h3 id="一些小知识，想到什么写什么"><a href="#一些小知识，想到什么写什么" class="headerlink" title="一些小知识，想到什么写什么"></a>一些小知识，想到什么写什么</h3><ul><li><p>列表与数组</p><ol><li>python中的列表可以包含不同类型的元素，如字符串、整数、浮点数等，而数组通常包含相同类型的元素</li><li>python中列表是动态数组，可以自动调整大小，而数组再创建时需要指定大小，一旦创建后，大小就不能再改变，因此在插入或删除元素时需要手动。</li><li>数组相当于列表来说在访问元素时性能更好，以为列表是动态数组插入或删除元素可能会有谢性能损失。</li></ol></li><li><p>元组<br><em>元组是一个集合是有序的和</em><strong>不可改变的</strong><br>元组使用小括号(),列表使用方括号[]<br>元组的创建很简单，只需要在括号中添加元素，使用逗号隔开即可</p></li><li><p>集(Set)<br>集合是无序和无索引的集合，在py中用{}表示</p><ol><li>添加一个项目到集合用add()</li></ol> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">thiset=&#123;<span class="hljs-string">&quot;apple&quot;</span>,<span class="hljs-string">&quot;banana&quot;</span>,<span class="hljs-string">&quot;cherry&quot;</span>&#125;<br>thiset.add(<span class="hljs-string">&quot;orange&quot;</span>)<br></code></pre></td></tr></table></figure><p> 2.添加多个项目用update()</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"> thiset=&#123;<span class="hljs-string">&quot;apple&quot;</span>,<span class="hljs-string">&quot;banana&quot;</span>,<span class="hljs-string">&quot;cherry&quot;</span>&#125;<br>thiset.update([<span class="hljs-string">&quot;orange&quot;</span>, <span class="hljs-string">&quot;mango&quot;</span>, <span class="hljs-string">&quot;grapes&quot;</span>])<br></code></pre></td></tr></table></figure><p> 3.删除用Remove()或discard()方法<br>  如果删除的项目不存在，remove()会引发错误，而discard()不会引发错误<br> 4.pop()删除最后一项<br> 5.clear()清空集合<br> …</p></li><li><p>字典</p><ol><li>使用values()函数返回字典的值</li></ol> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> thisdict.values():<br> <span class="hljs-built_in">print</span>(x)<br></code></pre></td></tr></table></figure><p>2.使用items()循环遍历键和值</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> x,y <span class="hljs-keyword">in</span> thisdict.items():<br> <span class="hljs-built_in">print</span>(x,y)<br></code></pre></td></tr></table></figure></li><li><p>匿名函数<br>  lambda函数是个匿名函数，可以使用任意数量的参数，但是只有一个表达式。</p><ul><li>用法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">lambda</span> arguments:expression<br><span class="hljs-comment"># ep1.返回一个加10的数</span><br>x=<span class="hljs-keyword">lambda</span> a:a+<span class="hljs-number">10</span><br><span class="hljs-comment"># ep2.可以使用任意数量的参数：</span><br>x=<span class="hljs-keyword">lambda</span> a,b,c:a+b+c<br><span class="hljs-built_in">print</span>(x(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>))<br></code></pre></td></tr></table></figure></li><li><p>迭代器<br>列表、元组、字典都是可迭代的对象，对于这些对象都有一个获取迭代器iter()方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">mytuple = (<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;cherry&quot;</span>)<br>myit = <span class="hljs-built_in">iter</span>(mytuple)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(myit))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(myit))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(myit))<br></code></pre></td></tr></table></figure><p>创建一个返回数字的迭代器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyNumbers</span>:<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>):<br>    self.a=<span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> self<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__next__</span>(<span class="hljs-params">self</span>):<br>    x=self.a<br>    self.a +=<span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> x<br><br>myclass = MyNumbers()<br>myiter = <span class="hljs-built_in">iter</span>(myclass)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(myiter))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(myiter))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(myiter))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(myiter))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(myiter))<br></code></pre></td></tr></table></figure></li><li><p>Stoplteration关键字<br>如果有足够的next()语句，为了防止迭代继续进行，可以使用StopIteration语句<br><em>ep1迭代20次后停止</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyNumbers</span>:<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>):<br>    self.a=<span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> self<br>  <br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__next__</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">if</span> self.a &lt;= <span class="hljs-number">20</span><br>      x = self.a<br>      self.a += <span class="hljs-number">1</span><br>      <span class="hljs-keyword">return</span> x<br>    <span class="hljs-keyword">else</span>:<br>      <span class="hljs-keyword">raise</span> StopIteration<br><br>myclass = MyNumbers()<br>myiter = <span class="hljs-built_in">iter</span>(myclass)<br><br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> myiter:<br>  <span class="hljs-built_in">print</span>(x)<br></code></pre></td></tr></table></figure></li><li><p>self<br>在python中,self是一个惯用的参数名称。在定义一个类的方法时，需要将self作为第一个参数传递给方法，当我们定义一个类的方法时，那么在调用该方法时，实际上是通过类的实例对象来调用这个方法，因此不需要显式传递self参数；<br>如果我们在类的方法中访问类的属性或者方法，那么必须使用self来访问。如果我们在方法中直接访问属性或者方法，py会解释为局部变量或函数，从而导致错误。</p></li><li><p>运算符</p><ul><li>&#x2F;&#x2F; –&gt; 取整数-往小的方向取整数<br><em>ep</em><blockquote><blockquote><blockquote><p>9&#x2F;&#x2F;2<br>4  </p></blockquote></blockquote></blockquote></li><li>** –&gt; 幂 返回x的y次幂</li><li>逻辑运算符</li></ul><ol><li>与 and –&gt; x and y</li><li>或 or  –&gt; x  or y</li><li>非 not –&gt; x not y</li></ol></li><li><p>二维数组初始化</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 创建一个rows行cols列的二维数组，初始值为0</span><br>matrix = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(cols)] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(rows)]<br><span class="hljs-comment"># 创建一个rows行cols列的二维数组，初始值为</span><br>matrix = [[<span class="hljs-number">0</span>] * cols <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(row)]<br></code></pre></td></tr></table></figure></li></ul><h3 id="py函数"><a href="#py函数" class="headerlink" title="py函数"></a>py函数</h3><ul><li><p>remove()<br>用于从列表中删除指定元素；语法格式为: list_name.remove(element) #element 任意数据类型</p><ol><li><p>删除普通类型元素<br>  删除列表中存在的数字或者字符串;不存在会报错，引发valueError异常</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">list1 = [<span class="hljs-string">&#x27;zhangsan&#x27;</span>, <span class="hljs-string">&#x27;lisi&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br>list1.remove(<span class="hljs-number">1</span>)<br>list1.remove(<span class="hljs-string">&#x27;lisi)</span><br></code></pre></td></tr></table></figure></li><li><p>删除对象类型元素  </p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">list1=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],(<span class="hljs-number">5</span>,<span class="hljs-number">6</span>)]<br>a=[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>b=(<span class="hljs-number">5</span>,<span class="hljs-number">6</span>)<br>list1.remove(a) <span class="hljs-comment"># 删除列表类型</span><br>list1.remove(b) <span class="hljs-comment"># 删除元组类型</span><br></code></pre></td></tr></table></figure></li><li><p>删除多个元素，可以使用循环来实现</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 创建一个列表</span><br>fruits = [<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;orange&quot;</span>, <span class="hljs-string">&quot;peach&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;kiwi&quot;</span>]<br><br><span class="hljs-comment"># 删除所有的 &quot;banana&quot; 元素</span><br><span class="hljs-keyword">while</span> <span class="hljs-string">&quot;banana&quot;</span> <span class="hljs-keyword">in</span> fruits:<br>    fruits.remove(<span class="hljs-string">&quot;banana&quot;</span>)<br><br><span class="hljs-built_in">print</span>(fruits)  <span class="hljs-comment"># [&quot;apple&quot;, &quot;orange&quot;, &quot;peach&quot;, &quot;kiwi&quot;]</span><br></code></pre></td></tr></table></figure></li></ol><p> 注意:<em>在使用 remove() 函数时要谨慎，特别是在迭代列表的过程中,当删除一个元素后会导致后面的元素索引发生变化从而可能导致发生错误</em></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>-Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/05/26/hello-world/"/>
    <url>/2023/05/26/hello-world/</url>
    
    <content type="html"><![CDATA[<h1 id="hexo添加新文章"><a href="#hexo添加新文章" class="headerlink" title="hexo添加新文章"></a>hexo添加新文章</h1><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haxe">hexo <span class="hljs-keyword">new</span> <span class="hljs-type">post</span> filename<br>编辑你的文件<br>hexo g -d <span class="hljs-comment">//完成推送到GitHub就行</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>hello</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hello World</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux命令</title>
    <link href="/2023/05/26/Linux%E5%91%BD%E4%BB%A4/"/>
    <url>/2023/05/26/Linux%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="Linux常用指令"><a href="#Linux常用指令" class="headerlink" title="Linux常用指令"></a>Linux常用指令</h2><ul><li>获取登录信息 -w &#x2F;who &#x2F;last &#x2F;lastb</li><li>查看自己使用的 -Shell -ps</li><li>查看命令的说明和位置 -whatis &#x2F;which &#x2F;whereis</li><li>清除屏幕上的内容 -clear</li><li>看帮助文档 -man&#x2F;info &#x2F;–help &#x2F;apropos</li><li>查看系统和主机名 -uname &#x2F;hostname</li><li>时间和日期 -date &#x2F;cal</li><li>重启和关机 -reboot &#x2F;shutdown</li></ul><h3 id="文件和文件夹操作"><a href="#文件和文件夹操作" class="headerlink" title="文件和文件夹操作"></a>文件和文件夹操作</h3><ul><li><p>创建&#x2F;删除空目录 -mkdir &#x2F;rmdir</p></li><li><p>创建&#x2F;删除文件 -touch &#x2F;rm</p><ul><li>touch命令用于创建空白文件或修改文件时间。在linux系统中一个文件有三种时间</li><li>更改内容的时间 -mtime</li><li>更改权限的时间 -ctime</li><li>最后访问时间 -atime</li></ul></li><li><p>rm的几个重要参数<br>    -i 交互式删除，每个删除项目都会进行询问<br>    -r 删除目录并递归的删除目录中的文件和目录<br>    -f 强制删除，忽略不存在的文件，没有任何提示</p></li><li><p>切换和查看当前工作目录 -cd &#x2F;pwd</p><ul><li>快捷键 运行结果</li><li>cd 更改工作目录到home。</li><li>cd - 更改工作目录到先前的工作目录。</li><li>cd ˜user_name 更改工作目录到home目录。例如, cd ˜bob 会更改工作目录到用“b录。</li></ul></li><li><p>查看目录内容 -ls<br> -l 以长格式查看文件和目录<br> -a 显示以点开头的文件（隐藏文件）<br> -R 遇到目录要进行递归展开(继续列出目录下面的文件和目录)<br> -d 只列出目录，不列出其他内容<br> -S &#x2F;-t 按大小&#x2F;时间排序</p></li><li><p>查看文件内容 -cat &#x2F; tac &#x2F; head &#x2F; tail &#x2F; more &#x2F; less &#x2F; rev &#x2F; od</p></li><li><p>拷贝&#x2F;移动文件 - cp &#x2F; mv </p></li><li><p>文件重命名 -rename</p></li><li><p>查找文件和查找内容 -find &#x2F; grep </p><ul><li>grep在搜索字符串是可以使用正则表达式，如果需要使用正则表达式可以用grep -E 或者直接使用egrep</li></ul></li><li><p>创建链接和查看链接 -ln &#x2F; readlink</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jupyter_Command</title>
    <link href="/2023/05/12/Jupyter-Command/"/>
    <url>/2023/05/12/Jupyter-Command/</url>
    
    <content type="html"><![CDATA[<h1 id="Jupyter常用的命令"><a href="#Jupyter常用的命令" class="headerlink" title="Jupyter常用的命令"></a>Jupyter常用的命令</h1><h2 id="命令模式下常用指令"><a href="#命令模式下常用指令" class="headerlink" title="命令模式下常用指令"></a>命令模式下常用指令</h2><ul><li>m键，可以直接输入markdown格式的内容，y键可以回到代码格式</li><li>Shift+回车 运行当前代码块</li><li>Ctrl+回车 只运行当前代码块</li><li>Alt+回车 运行当前代码块并向下新建一个代码块</li><li>按b向下新建一个代码块</li><li>按a向上新建一个代码块</li><li>按c复制当前代码块</li><li>按x剪切当前代码块</li><li>按v粘贴当前代码块；shift+v,粘贴到上一个代码块</li><li>按z撤回操作</li><li>按dd两次删除代码块</li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jupyter notebook</tag>
      
      <tag>py</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git_merge笔记</title>
    <link href="/2023/04/06/git-merge%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/04/06/git-merge%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="gitub问题-master和main分支合并"><a href="#gitub问题-master和main分支合并" class="headerlink" title="gitub问题:master和main分支合并"></a>gitub问题:master和main分支合并</h2><p>问题:github创建仓库后默认分支是main，而本地创建的是master</p><ol><li><p>先给本地master改名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs git">git branch -M main<br>//-M对分支重命名<br></code></pre></td></tr></table></figure></li><li><p>查看所有分支</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs git">git branch -a<br>* main   <br>remotes/origin/main   <br>remotes/origin/master  <br></code></pre></td></tr></table></figure></li><li><p>删除远程分支master</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs git">  $ git push origin --delete master <br>To https://github.com/<br>     - [deleted]         master  <br></code></pre></td></tr></table></figure></li><li><p>确认删除情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs git">$git branch -a<br>* main<br>remotes/origin/main<br></code></pre></td></tr></table></figure></li><li><p>切换当前分支main，也就要保留下来的分支</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs git">$ git checkout main <br>Already on &#x27;main&#x27; <br></code></pre></td></tr></table></figure></li><li><p>合并分支</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs git">$ git merge remotes/origin/main <br>fatal: refusing to merge unrelated histories <br></code></pre></td></tr></table></figure><p> 说明:拒绝合并，需要忽略这个限制，添加”–allow–unrelated-histories”</p></li><li><p>提交修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git push origin main<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2023/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2023/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="计网"><a href="#计网" class="headerlink" title="计网"></a>计网</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>因特网服务提供者<strong>ISP</strong><br><img src="/image/../../image/20230403163628.png"></p><h3 id="因特网的组成"><a href="#因特网的组成" class="headerlink" title="因特网的组成"></a>因特网的组成</h3><ol><li>边缘部分<br> 由所有连接在因特网上的主机组成，这部分是用户直接使用和资源共享</li><li>核心部分<br> 由大量网络和连接这些网络的路由器组成，这部分是为边缘部分提供服务的</li></ol><h3 id="三种交换方式"><a href="#三种交换方式" class="headerlink" title="三种交换方式"></a>三种交换方式</h3><p><strong>电路交换</strong></p><ol><li>电话交换机接通电话线的方式</li><li>电路交换的三个步骤<ol><li>建立连接 (分配通信资源)</li><li>通话(一直占用资源)</li><li>释放连接(归还通信资源)</li></ol></li><li>当使用电路交换来传送计算机数据时，线路的传输效率往往很低<br><img src="/image/../../../public/image/QQ%E6%88%AA%E5%9B%BE20230403165712.png"></li></ol><p><strong>分组交换</strong><br>发送方:构造分组发送分组<br>路由器:缓存分组转发分组<br>接收方:接受分组还原报文<br><strong>报文交换</strong><br>与分组类似，主要用于早期的电报通信网，现在较少使用  </p><p><em>三者对比</em><br><img src="/image/../../image/QQ%E6%88%AA%E5%9B%BE20230403170409.png"><br><strong>三者优缺点</strong><br><em>电路交换</em>:</p><ol><li>优点<ol><li>通信时延小</li><li>有序传输</li><li>没有冲突</li><li>适用范围广</li><li>实时性强</li><li>控制简单</li></ol></li><li>缺点<ol><li>建立连接时间长</li><li>线路独占，使用效率低</li><li>灵活性差</li><li>难以规格化</li></ol></li></ol><p><em>报文交换</em>:</p><ol><li>优点<ol><li>无需建立连接</li><li>动态分配线路</li><li>提高线路可靠性</li><li>提高线路利用率</li><li>提供多目标服务</li></ol></li><li>缺点<ol><li>引起转发时延</li><li>需要较大存储缓存空间</li><li>需要传输额外的信息量</li></ol></li></ol><p><em>分组交换</em>:</p><ol><li>优点<ol><li>无需建立连接</li><li>线路利用率高</li><li>简化了储存管理</li><li>加速传输</li><li>减少出错概率和重发数据量</li></ol></li><li>缺点<ol><li>引起转发时延</li><li>需要传输额外的信息量</li><li>对于数据服务，存在失序，丢失或重复分组的问题，对于虚电路服务，存在呼叫建立，数据传输和虚电路释放三个过程</li></ol></li></ol><h3 id="计算机网络分类"><a href="#计算机网络分类" class="headerlink" title="计算机网络分类"></a>计算机网络分类</h3><h5 id="按交换技术分类"><a href="#按交换技术分类" class="headerlink" title="按交换技术分类"></a>按交换技术分类</h5><ol><li>电路交换网络</li><li>报文交换网络</li><li>分组交换网络</li></ol><h5 id="按使用者分"><a href="#按使用者分" class="headerlink" title="按使用者分"></a>按使用者分</h5><ol><li>公用网</li><li>专用网</li></ol><h5 id="按传输介质分类"><a href="#按传输介质分类" class="headerlink" title="按传输介质分类"></a>按传输介质分类</h5><ol><li>有线网络</li><li>无线网络</li></ol><h5 id="按覆盖范围分类"><a href="#按覆盖范围分类" class="headerlink" title="按覆盖范围分类"></a>按覆盖范围分类</h5><ol><li>广域网 WAN</li><li>域域网 WAN</li><li>局域网 LAN</li><li>个域网 PAN</li></ol><h5 id="按拓扑结构分类"><a href="#按拓扑结构分类" class="headerlink" title="按拓扑结构分类"></a>按拓扑结构分类</h5><ol><li>总线型网络</li><li>星形网络</li><li>环形网络</li><li>网状型网络</li></ol><h3 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h3><h4 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h4><p>速率:是指在计算机网络上的主机在数字信道上传送比特的速率，也称为比特率或数据率<br>比特:计算机中数据量的单位<br><em>常用数据量单位</em><br><img src="/image/./../../image/QQ%E6%88%AA%E5%9B%BE20230403200115.png"><br><em>常用数据率单位</em><br><img src="/image/../../image/QQ%E6%88%AA%E5%9B%BE20230403200140.png"></p><h4 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h4><p>带宽:(在计算机网络中的意义)用来表示网络的通信线路所能传送数据的能力。<br>一条通信线路的频带宽度越宽，其所传输的最高数据率也越高<br><em>单位:b&#x2F;s(kb&#x2F;s,Mb&#x2F;s,Gb&#x2F;s,Tb&#x2F;s)</em></p><h4 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h4><p>吞吐量：表示单位时间内通过某个网络的数据量<br>吞吐量受网络带宽或额定速率的限制</p><h4 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h4><ol><li>发送时延<br>$$\frac{分组长度(b)}{发送速率(b&#x2F;s)}$$</li><li>传播时延<br>  $$\frac{信道长度(m)}{电磁波传播速率(m&#x2F;s)}$$<em>电磁波传播速率:1.自由空间 3x10^8m&#x2F;s 2.铜线 2.3x10^8m&#x2F;s 3.光纤 2.0x10^8m&#x2F;s</em></li><li>处理时延<br>一般不方便计算</li></ol><h4 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h4><p>时延带宽积&#x3D;传播时延X带宽<br><img src="/image/../../image/QQ%E6%88%AA%E5%9B%BE20230404213025.png"></p><h4 id="往返时间-RTT"><a href="#往返时间-RTT" class="headerlink" title="往返时间 RTT"></a>往返时间 RTT</h4><p><img src="/image/./../../image/QQ%E6%88%AA%E5%9B%BE20230404213323.png"></p><h4 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h4><p>$$利用率&#x3D;\left{\begin{array}{l}<br>信道利用率:表示某信道有百分之几的时间是利用的\ 网络利用率:全网络的信道利用率的加权平均<br>\end{array}\right.$$<br><img src="/image/../../image/QQ%E6%88%AA%E5%9B%BE20230404215035.png"></p><h4 id="丢包率"><a href="#丢包率" class="headerlink" title="丢包率"></a>丢包率</h4><p>丢包率是指在一定时间范围内，传输过程中丢失的分组数量与总分组数量的比率<br>分组丢失主要有两种情况<br>    1. 分组在传输过程中出现误码被结点丢弃<br>    2. 分组到达一台队列已满的分组交换机时被丢弃；在通信量较大时就可能造成网络拥塞<br>丢包率也反应了网络的拥塞情况</p><ol><li>无拥塞时路径丢包率为0</li><li>轻度拥塞时路径丢包率为1%-4%</li><li>严重拥塞时路劲丢包率为5%-15%</li></ol>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
