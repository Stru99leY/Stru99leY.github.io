[{"title":"Jupyter_Command","url":"/2023/05/12/Jupyter-Command/","content":"Jupyter常用的命令命令模式下常用指令\nm键，可以直接输入markdown格式的内容，y键可以回到代码格式\nShift+回车 运行当前代码块\nCtrl+回车 只运行当前代码块\nAlt+回车 运行当前代码块并向下新建一个代码块\n按b向下新建一个代码块\n按a向上新建一个代码块\n按c复制当前代码块\n按x剪切当前代码块\n按v粘贴当前代码块；shift+v,粘贴到上一个代码块\n按z撤回操作\n按dd两次删除代码块\n\n","categories":["笔记"],"tags":["jupyter notebook","python"]},{"title":"Hello World","url":"/2023/05/26/hello-world/","content":"hexo添加新文章hexo new post filename编辑你的文件hexo g -d //完成推送到GitHub就行","categories":["hello"],"tags":["Hello World"]},{"title":"git_merge笔记","url":"/2023/04/06/git-merge%E7%AC%94%E8%AE%B0/","content":"gitub问题:master和main分支合并问题:github创建仓库后默认分支是main，而本地创建的是master\n\n先给本地master改名\ngit branch -M main//-M对分支重命名\n\n查看所有分支\n git branch -a* main   remotes/origin/main   remotes/origin/master  \n\n删除远程分支master\n  $ git push origin --delete master To https://github.com/     - [deleted]         master  \n\n确认删除情况\n$git branch -a* mainremotes/origin/main\n\n切换当前分支main，也就要保留下来的分支\n $ git checkout main Already on &#x27;main&#x27; \n\n合并分支\n $ git merge remotes/origin/main fatal: refusing to merge unrelated histories \n\n 说明:拒绝合并，需要忽略这个限制，添加”–allow–unrelated-histories”\n\n提交修改\ngit push origin main\n\n","categories":["随笔"],"tags":["git"]},{"title":"计算机网络","url":"/2023/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","content":"计网概述因特网服务提供者ISP\n因特网的组成\n边缘部分 由所有连接在因特网上的主机组成，这部分是用户直接使用和资源共享\n核心部分 由大量网络和连接这些网络的路由器组成，这部分是为边缘部分提供服务的\n\n三种交换方式电路交换\n\n电话交换机接通电话线的方式\n电路交换的三个步骤\n建立连接 (分配通信资源)\n通话(一直占用资源)\n释放连接(归还通信资源)\n\n\n当使用电路交换来传送计算机数据时，线路的传输效率往往很低\n\n分组交换发送方:构造分组发送分组路由器:缓存分组转发分组接收方:接受分组还原报文报文交换与分组类似，主要用于早期的电报通信网，现在较少使用  \n三者对比三者优缺点电路交换:\n\n优点\n通信时延小\n有序传输\n没有冲突\n适用范围广\n实时性强\n控制简单\n\n\n缺点\n建立连接时间长\n线路独占，使用效率低\n灵活性差\n难以规格化\n\n\n\n报文交换:\n\n优点\n无需建立连接\n动态分配线路\n提高线路可靠性\n提高线路利用率\n提供多目标服务\n\n\n缺点\n引起转发时延\n需要较大存储缓存空间\n需要传输额外的信息量\n\n\n\n分组交换:\n\n优点\n无需建立连接\n线路利用率高\n简化了储存管理\n加速传输\n减少出错概率和重发数据量\n\n\n缺点\n引起转发时延\n需要传输额外的信息量\n对于数据服务，存在失序，丢失或重复分组的问题，对于虚电路服务，存在呼叫建立，数据传输和虚电路释放三个过程\n\n\n\n计算机网络分类按交换技术分类\n电路交换网络\n报文交换网络\n分组交换网络\n\n按使用者分\n公用网\n专用网\n\n按传输介质分类\n有线网络\n无线网络\n\n按覆盖范围分类\n广域网 WAN\n域域网 WAN\n局域网 LAN\n个域网 PAN\n\n按拓扑结构分类\n总线型网络\n星形网络\n环形网络\n网状型网络\n\n计算机网络的性能指标速率速率:是指在计算机网络上的主机在数字信道上传送比特的速率，也称为比特率或数据率比特:计算机中数据量的单位常用数据量单位常用数据率单位\n带宽带宽:(在计算机网络中的意义)用来表示网络的通信线路所能传送数据的能力。一条通信线路的频带宽度越宽，其所传输的最高数据率也越高单位:b&#x2F;s(kb&#x2F;s,Mb&#x2F;s,Gb&#x2F;s,Tb&#x2F;s)\n吞吐量吞吐量：表示单位时间内通过某个网络的数据量吞吐量受网络带宽或额定速率的限制\n时延\n发送时延$$\\frac{分组长度(b)}{发送速率(b&#x2F;s)}$$\n传播时延  $$\\frac{信道长度(m)}{电磁波传播速率(m&#x2F;s)}$$电磁波传播速率:1.自由空间 3x10^8m&#x2F;s 2.铜线 2.3x10^8m&#x2F;s 3.光纤 2.0x10^8m&#x2F;s\n处理时延一般不方便计算\n\n时延带宽积时延带宽积&#x3D;传播时延X带宽\n往返时间 RTT\n利用率$$利用率&#x3D;\\left{\\begin{array}{l}信道利用率:表示某信道有百分之几的时间是利用的\\ 网络利用率:全网络的信道利用率的加权平均\\end{array}\\right.$$\n丢包率丢包率是指在一定时间范围内，传输过程中丢失的分组数量与总分组数量的比率分组丢失主要有两种情况    1. 分组在传输过程中出现误码被结点丢弃    2. 分组到达一台队列已满的分组交换机时被丢弃；在通信量较大时就可能造成网络拥塞丢包率也反应了网络的拥塞情况\n\n无拥塞时路径丢包率为0\n轻度拥塞时路径丢包率为1%-4%\n严重拥塞时路劲丢包率为5%-15%\n\n","categories":["笔记"],"tags":["计算机网络"]},{"title":"Linux命令","url":"/2023/05/26/Linux%E5%91%BD%E4%BB%A4/","content":"Linux常用指令\n获取登录信息 -w &#x2F;who &#x2F;last &#x2F;lastb\n查看自己使用的 -Shell -ps\n查看命令的说明和位置 -whatis &#x2F;which &#x2F;whereis\n清除屏幕上的内容 -clear\n看帮助文档 -man&#x2F;info &#x2F;–help &#x2F;apropos\n查看系统和主机名 -uname &#x2F;hostname\n时间和日期 -date &#x2F;cal\n重启和关机 -reboot &#x2F;shutdown\n\n文件和文件夹操作\n创建&#x2F;删除空目录 -mkdir &#x2F;rmdir\n\n创建&#x2F;删除文件 -touch &#x2F;rm\n\ntouch命令用于创建空白文件或修改文件时间。在linux系统中一个文件有三种时间\n更改内容的时间 -mtime\n更改权限的时间 -ctime\n最后访问时间 -atime\n\n\nrm的几个重要参数    -i 交互式删除，每个删除项目都会进行询问    -r 删除目录并递归的删除目录中的文件和目录    -f 强制删除，忽略不存在的文件，没有任何提示\n\n切换和查看当前工作目录 -cd &#x2F;pwd\n\n快捷键 运行结果\ncd 更改工作目录到home。\ncd - 更改工作目录到先前的工作目录。\ncd ˜user_name 更改工作目录到home目录。例如, cd ˜bob 会更改工作目录到用“b录。\n\n\n查看目录内容 -ls -l 以长格式查看文件和目录 -a 显示以点开头的文件（隐藏文件） -R 遇到目录要进行递归展开(继续列出目录下面的文件和目录) -d 只列出目录，不列出其他内容 -S &#x2F;-t 按大小&#x2F;时间排序\n\n查看文件内容 -cat &#x2F; tac &#x2F; head &#x2F; tail &#x2F; more &#x2F; less &#x2F; rev &#x2F; od\n\n拷贝&#x2F;移动文件 - cp &#x2F; mv \n\n文件重命名 -rename\n\n查找文件和查找内容 -find &#x2F; grep \n\ngrep在搜索字符串是可以使用正则表达式，如果需要使用正则表达式可以用grep -E 或者直接使用egrep\n\n\n创建链接和查看链接 -ln &#x2F; readlink\n\n\n","categories":["笔记"],"tags":["Linux"]},{"title":"Python随笔","url":"/2023/06/03/Python%E9%9A%8F%E7%AC%94/","content":"Python的一些不熟悉的知识一些小知识，想到什么写什么\n列表与数组\n\npython中的列表可以包含不同类型的元素，如字符串、整数、浮点数等，而数组通常包含相同类型的元素\npython中列表是动态数组，可以自动调整大小，而数组再创建时需要指定大小，一旦创建后，大小就不能再改变，因此在插入或删除元素时需要手动。\n数组相当于列表来说在访问元素时性能更好，以为列表是动态数组插入或删除元素可能会有些性能损失。\n\n\n元组元组是一个集合是有序的和不可改变的元组使用小括号(),列表使用方括号[]元组的创建很简单，只需要在括号中添加元素，使用逗号隔开即可\n\n集(Set)集合是无序和无索引的集合，可以用来快速判断一个元素是否在某个集合中，在py中用{}表示\n\n添加一个项目到集合用add()\n thiset=&#123;&quot;apple&quot;,&quot;banana&quot;,&quot;cherry&quot;&#125;thiset.add(&quot;orange&quot;)\n\n添加多个项目用update()\n   thiset=&#123;&quot;apple&quot;,&quot;banana&quot;,&quot;cherry&quot;&#125;thiset.update([&quot;orange&quot;, &quot;mango&quot;, &quot;grapes&quot;])\n\n删除用Remove()或discard()方法  如果删除的项目不存在，remove()会引发错误，而discard()不会引发错误\n\npop()删除最后一项\n\nclear()清空集合 …\n\n\n\n字典\n\n使用values()函数返回字典的值\n for x in thisdict.values():  print(x)\n\n使用items()循环遍历键和值\n for x,y in thisdict.items():  print(x,y)\n\ndict()创建字典\n epdict = dict()print(epdict) # 输出&#123;&#125;print(len(epdict)) # 输出0print(type(epdict)) # &lt;class &#x27;dict&#x27;&gt;\n\n\n字典的访问\n使用中括号[ ]  \n dic = &#123;&#x27;key1&#x27;: &#x27;value1&#x27;, &#x27;key2&#x27;: &#x27;value2&#x27;, &#x27;key3&#x27;: &#x27;value3&#x27;&#125;print(dic[&#x27;key1&#x27;])  # 输出 value1\n\n使用get( )方法  dic.get(key,default&#x3D;None)它用于从字典中获取指定键key对应的值，键不存在返回一个默认值deafult\n dic = &#123;&#x27;key1&#x27;: &#x27;value1&#x27;, &#x27;key2&#x27;: &#x27;value2&#x27;, &#x27;key3&#x27;: &#x27;value3&#x27;&#125;print(dic.get(&#x27;key1&#x27;)) # 输出value1print(dic.get(&#x27;key4&#x27;)) # 输出 None\n\n除以上外，可以通过keys(),values()和items()方法获取字典中所有的键、值和键值对。例如:\n dic = &#123;&#x27;key1&#x27;: &#x27;value1&#x27;, &#x27;key2&#x27;: &#x27;value2&#x27;, &#x27;key3&#x27;: &#x27;value3&#x27;&#125;print(dic.keys()) # 输出 dict_keys([&#x27;key1&#x27;, &#x27;key2&#x27;, &#x27;key3&#x27;])print(dic.values()) # 输出 dict_values([&#x27;value1&#x27;, &#x27;value2&#x27;, &#x27;value3&#x27;])print(dic.items()) # dict_items([(&#x27;key1&#x27;, &#x27;value1&#x27;), (&#x27;key2&#x27;, &#x27;value2&#x27;), (&#x27;key3&#x27;, &#x27;value3&#x27;)])\n\n 注意:keys()、values()、items()方法返回的是一种特殊的视图对象，而不是普通的列表。要转换成列表可以用list()函数\n\n\n\n\n\n频率看到计算频率等问题直接联想到以下代码:\nfor i in nums:  dic[i] = dic.get(i,0) + 1\n\n取整使用int取整大于0的数向下取整，小于0的数向上取整\n\n匿名函数  lambda函数是个匿名函数，可以使用任意数量的参数，但是只有一个表达式。\n\n用法\n\nlambda arguments:expression# ep1.返回一个加10的数x=lambda a:a+10# ep2.可以使用任意数量的参数：x=lambda a,b,c:a+b+cprint(x(1,2,3))\n\n迭代器列表、元组、字典都是可迭代的对象，对于这些对象都有一个获取迭代器iter()方法\nmytuple = (&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;)myit = iter(mytuple)print(next(myit))print(next(myit))print(next(myit))\n\n创建一个返回数字的迭代器\nclass MyNumbers:  def __iter__(self):    self.a=1    return self  def __next__(self):    x=self.a    self.a +=1    return xmyclass = MyNumbers()myiter = iter(myclass)print(next(myiter))print(next(myiter))print(next(myiter))print(next(myiter))print(next(myiter))\n\nStoplteration关键字如果有足够的next()语句，为了防止迭代继续进行，可以使用StopIteration语句ep1迭代20次后停止\nclass MyNumbers:  def __iter__(self):    self.a=1    return self    def __next__(self):    if self.a &lt;= 20      x = self.a      self.a += 1      return x    else:      raise StopIterationmyclass = MyNumbers()myiter = iter(myclass)for x in myiter:  print(x)\n\nself在python中,self是一个惯用的参数名称。在定义一个类的方法时，需要将self作为第一个参数传递给方法，当我们定义一个类的方法时，那么在调用该方法时，实际上是通过类的实例对象来调用这个方法，因此不需要显式传递self参数；如果我们在类的方法中访问类的属性或者方法，那么必须使用self来访问。如果我们在方法中直接访问属性或者方法，py会解释为局部变量或函数，从而导致错误。\n\n运算符\n\n&#x2F;&#x2F; –&gt; 取整数-往小的方向取整数ep\n\n\n9&#x2F;&#x2F;24\n\n\n\n\n** –&gt; 幂 返回x的y次幂\n逻辑运算符\n\n\n与 and –&gt; x and y\n或 or  –&gt; x  or y\n非 not –&gt; x not y\n\n\n二维数组初始化\n  # 创建一个rows行cols列的二维数组，初始值为0matrix = [[0 for _ in range(cols)] for _ in range(rows)]# 创建一个rows行cols列的二维数组，初始值为matrix = [[0] * cols for _ in range(row)]\n\n字符串格式化例子:\nname = &quot;张三&quot;age = 18print(&quot;我叫%s，今年%d岁。&quot; % (name, age)) # 输出: &quot;我叫张三，今年18岁。&quot;\n\ntrytry和except语句来处理异常，try语句块用于包裹可能会引发异常的代码，而except来处理可能引发的异常，除此之外还可以使用else和finally语句块来进一步处理异常。else语句块中的代码会在try语句块中没有发生异常时执行，而finally语句中的代码无论是否发生异常都会执行。\ntry:  x = 10 / 2except ZeroDivisionError:  print(&quot;除数不能为零&quot;)else:  print(&quot;结果为:&quot;, x)finally:  print(&quot;无论是否发生异常，都会执行这里的代码&quot;)\n\nexcept异常由以下几种:\n  Exception：所有异常的基类，可以捕获任何类型的异常。ZeroDivisionError：除以零时引发的异常。TypeError：类型不匹配时引发的异常。ValueError：值不合法或无效时引发的异常。IndexError：索引超出范围时引发的异常。KeyError：字典中使用不存在的键时引发的异常。FileNotFoundError：打开或读取文件时找不到文件时引发的异常。NameError：尝试访问不存在的变量或函数时引发的异常。ImportError：导入模块失败时引发的异常。IOError：输入/输出操作失败时引发的异常。\n\n推导式用于快速创建列表、字典、集合等可迭代对象，一般有以下几种:\n\n列表推导式 语法形式计为:[expression for item in iterable if condition]或者[expression for item in iterable] 示例:\n\n过滤长度小于或者等于3的字符串列表，并将剩下的转换成大写字母:\n\n names = [&#x27;Bob&#x27;,&#x27;Tom&#x27;,&#x27;alice&#x27;,&#x27;Jerry&#x27;,&#x27;Wendy&#x27;,&#x27;Smith&#x27;]new_names = [name.upper()for name in names if len(name)&gt;=3]print(new_names)# 输出[&#x27;ALICE&#x27;, &#x27;JERRY&#x27;, &#x27;WENDY&#x27;, &#x27;SMITH&#x27;]\n\n字典推导式  语法形式为:{key_expr:value for value in collction} 或者 {key_expr:value for value in collction if condition}  示例:\n\n使用字符串及其长度创建字典\n\n  listdemo = [&#x27;Google&#x27;,&#x27;Runoob&#x27;, &#x27;Taobao&#x27;]newdic = &#123;key:len(key) for key in listdemo&#125;newdic# 输出&#123;&#x27;Google&#x27;: 6, &#x27;Runoob&#x27;: 6, &#x27;Taobao&#x27;: 6&#125;\n\n集合推导式 语法形式为:{expression for item in Sequence} 或者 {expression for item in Sequence if condition} 示例:\n\n判断不是abc的字母并输出\n\n a = &#123;x for x in &#x27;abracadabra&#x27; if x not in &#x27;abc&#x27;&#125;a# 输出 &#123;&#x27;d&#x27;,&#x27;r&#x27;&#125;type(a)# 输出 &lt;class &#x27;set&#x27;&gt;\n\n元组推导式(生成器表达式) 可以利用range区间、元组、列表、字典和集合等数据结构类型，快速生成一个满足指定需求的元组，语法形式为:(expression for item in Sequence) 或者 (expression for item in Sequence if condition)\n\n\n\n元组推导式和列表推导式用法完全相同，只是元组推导式是用()圆括号,列表推导式是用[]中括号，类外元组推导式返回的结果也是一个生成器对象 示例:\n\n\n\n\n生成一个包含数字1-9的元组：\n\n a= (x for x in range(1,10))a# &lt;generator object &lt;genexpr&gt; at 0x7faf6ee20a50&gt; 返回是是生成器对象tuple(a)# 转换为元组 (1, 2, 3, 4, 5, 6, 7, 8, 9)\n\n\nstack下标问题正数索引(从0开始)，列表元素的顺序从左到右。而对于负数索引(从-1开始),元素顺序是从右到左；相当于一个是入栈一个是出栈\n\n\npy函数\nremove()用于从列表中删除指定元素；语法格式为: list_name.remove(element) #element 任意数据类型\n\n删除普通类型元素  删除列表中存在的数字或者字符串;不存在会报错，引发valueError异常\n list1 = [&#x27;zhangsan&#x27;, &#x27;lisi&#x27;, 1, 2]list1.remove(1)list1.remove(&#x27;lisi&#x27;)\n\n删除对象类型元素  \n list1=[1,2,[3,4],(5,6)]a=[3,4]b=(5,6)list1.remove(a) # 删除列表类型list1.remove(b) # 删除元组类型\n\n删除多个元素，可以使用循环来实现\n # 创建一个列表fruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;, &quot;peach&quot;, &quot;banana&quot;, &quot;kiwi&quot;]# 删除所有的 &quot;banana&quot; 元素while &quot;banana&quot; in fruits:    fruits.remove(&quot;banana&quot;)print(fruits)  # [&quot;apple&quot;, &quot;orange&quot;, &quot;peach&quot;, &quot;kiwi&quot;]\n\n 注意:在使用 remove() 函数时要谨慎，特别是在迭代列表的过程中,当删除一个元素后会导致后面的元素索引发生变化从而可能导致发生错误\n\nenumerate()enumerate()是python中的一个内置函数，将一个可迭代对象转换为一个枚举对象，同时返回每个元素的索引和值，常用于for循环中获取中获取每个元素的位置信息。用法: enumerate(iterable,start&#x3D;0)其中，iterable表示要枚举的可迭代对象，start表示起始索引\n\nord()ord()是一个内置函数，用于获取给定字符的Unicode码点值，ord()函数接受单个字符作为参数；\n  ord(&#x27;a&#x27;) # 返回97  ```  - defaultdict()  defaultdict是python中的一个内置字典子类，重载了一个方法来实现默认值的设定。在创建defaultdict对象，需要提供一个参数作为默认值或者一个函数用来生成默认值。  比如有一个字典对其中的值进行累加操作，如果某个键不存在，则将其值设置为0，使用defaultdict可以避免手动判断键是否存在的过程:  ```python  from collections import defaultdict  d = defaultdict(int)  # 对字典中的值进行累加操作  for i in &#x27;mississippi&#x27;：    d[i]+=1  print(d) # 输出：defaultdict(&lt;class &#x27;int&#x27;&gt;, &#123;&#x27;m&#x27;: 1, &#x27;i&#x27;: 4, &#x27;s&#x27;: 4, &#x27;p&#x27;: 2&#125;)\n\nsorted()返回一个新的排好序的列表，而不改变原始列表例如有一个数字列表\n\n\nnum = [4, 2, 7, 1, 3]\n\n我们可以使用sorted()进行排序、会返回一个新的列表，但是排序后会改变数字原有的索引值\nsorted_list = sorted(nums)\n\n若不想改变原数组的索引值可以用以下方法\n# 对nums的元素进行排序，排序的依据是nums中对应的位置，对于nums中的每个元素k，使用nums[k]的值作为排序关键字sorted(nums,key=lambda k:nums[k]])# 使用enumerate()生产一个包含元素索引和值的可迭代对象，按照值进行排序，不改变原有元素的索引值sorted_nums = soreted(enumerate(nums),key=lambda x:x[1])\n\n对于上述第二种方法，enumerate(nums)会返回一个(index,value)的元组.  \n","categories":["Python"],"tags":["基础知识"]},{"title":"MarkDown语法","url":"/2023/06/04/MarkDown%E8%AF%AD%E6%B3%95/","content":"这是一级标题这是二级标题这是三级标题换行的话在末尾打两个空格然后回车就能换行\n斜文字 ctrl+i文字加粗 ctrl+b  \n插入图片直接复制进来就可以  \n表格\n\n\n大明\n小明\n小红\n\n\n\n101\n21\n23\n\n\n冒号在哪边就往哪边对齐\n\n\n\n\n链接这是一个链接\ncodeprintf(&quot;hello world&quot;);\n\n\n实心点\n\n","categories":["MarkDown"],"tags":["语法"]},{"title":"力扣<py>","url":"/2023/06/04/%E5%8A%9B%E6%89%A3-py/","content":"977.有序数的平方\n使用python推导式+内置sort函数表达式:[表达式 for 变量 in 列表] or [表达式 for 变量 in 列表 条件] 使用推导式计算平方后的数据，再调用sort()方法完成排序\n class Solution:    def sortedSquares(self, nums: List[int]) -&gt; List[int]:        res=[num**2 for num in nums]        res.sort()        return res\n\n采用快排超出时间限制  \n  class Solution:def Partion(self,res,low,high):    i=(low - 1)    pivot=res[high]    for j in range(low,high):        if res[j]&lt;=pivot:            i=i+1            res[i],res[j]=res[j],res[i] # 小于pivot的往后移动    res[i+1],res[high]=res[high],res[i+1] #把pivot放入合适位置    return (i+1)def Qsort(self,res,low,high):    if low &lt;high :        pi = self.Partion(res,low,high)        self.Qsort(res,low,pi-1)        self.Qsort(res,pi+1,high)def sortedSquares(self, nums: List[int]) -&gt; List[int]:    res=[num**2 for num in nums]    self.Qsort(res,0,len(nums)-1)    return res\n\n双指针 采用双指针，left和right。先建立一个新的数组其值是nums数组平方后的，然后left指向第一个，right指向最后一个，在定义s为新指针，从当left&lt;&#x3D;right时，双向遍历，并将其值大的一个放入原数组nums的最后，当一次遍历完时，nums数组也完成了从小到大的排序。\nclass Solution: def sortedSquares(self, nums: List[int]) -&gt; List[int]:     res=[num**2 for num in nums]     left=0     right=len(nums)-1     s=right #s是新指针，从后往前排     # 大的往后排     while left&lt;=right:         if res[left]&lt;=res[right]:             nums[s]=res[right]             s-=1             right-=1         else:             nums[s]=res[left]             s-=1             left+=1     return nums\n\n27.移除元素\n一次遍历把不等于val的值放入数组中\nclass Solution: def removeElement(self, nums: List[int], val: int) -&gt; int:     if (nums == None and len(nums)==0):         return 0     s=0 # s的值代表数组的下标     for f in range(0,len(nums)):         if (nums[f]!=val):             nums[s]=nums[f]             s+=1     return s\n\n59.螺旋矩阵||\n采用四个循环每次循环解决一个方向 初始化数组后先从左边开始解决，矩阵是n*n的大小，将矩阵第一个默认设置为1，设置一个变量cnt&#x3D;2，从第二个开始依次填充，当下一位位置未被填充时填充cnt，当左边达到边界并且下一个是未被填充时，开始像下填充，同理，当向下填充达到边界且下一个未被填充后向左，再向上，当cnt&#x3D;&#x3D;n^2时完成螺旋矩阵\n class Solution:def generateMatrix(self, n: int) -&gt; List[List[int]]:    nums = [[0] * n for _ in range(n)] # 初始化数组 n行n列    i=0    j=0    cnt = 2    nums[0][0]=1    while cnt &lt;= n*n:        # left        while j&lt;n-1 and nums[i][j+1]==0:            j +=1            nums[i][j]=cnt            cnt +=1        # down        while i&lt;n-1 and nums[i+1][j]==0:            i+=1            nums[i][j]=cnt            cnt+=1        # left        while j&gt;0 and nums[i][j-1]==0:            j-=1            nums[i][j]=cnt            cnt +=1        # up        while i&gt;0 and nums[i-1][j]==0:            i-=1            nums[i][j]=cnt            cnt +=1    return nums\n\n1.两数之和\n双重循环利用两个for循环完成查找\n class Solution:def twoSum(self, nums: List[int], target: int) -&gt; List[int]:    ans=[0] *2     for i in range(len(nums)):        for j in range(i + 1, len(nums)):            # 如果两个数相加等于target记录其下标             if nums[i] + nums[j] == target:                ans[0] = i                ans[1] = j    return ans\n\n字典+枚举 从评论区看到的方法，利用字典的键值配对，和target0-val来找另一个val的方式，很巧妙 字典+枚举的方式可以优化算法使得时间复杂度＜o(n^2) 先使用dict()函数创建一个空的records字典，然后再用enumerate()函数将nums变成枚举类型，遍历nums，判断target - val是否在字典records里面(若数组中有两个数val加起来等于target，那么target-val的值也一定在数组中)，若不在则将val和其下标index记录字典，若在字典中则返回target-val值的下标和val的下标，即为所求，代码如下：\n class Solution:def twoSum(self, nums: List[int], target: int) -&gt; List[int]:    records=dict()    for index,val in enumerate(nums):        if target - val not in records:            records[val]=index # 记录当前val的索引值到字典中        else:             return [records[target-val],index]\n\n重新排序+双指针 利用sorted()函数将数组重新排序，注意:不能直接排序nums数组，这这样会改变其原有的索引值，可以用下面两种方法来排序:1.利用numerate()函数将nums转换成元组，按照值来排序，这样不会改变其原有元素的索引值。2.直接排序原数组的下标，将待排序的数组利用range(len(nums))生产一个0~len(nums)-1的序列，按照nums数组的值来进行排序，这样就能得到一个按照值来排序的索引数组。排好序后，利用双指针head和tail一个从前往后一个从后往前，依次遍历判断和与target的关系，两种方式的代码如下: 第一种：\n class Solution:def twoSum(self, nums: List[int], target: int) -&gt; List[int]:    sorted_list = sorted(enumerate(nums),key=lambda x: x[1]) # 排好序的元组    head = 0    tail = len(nums) - 1    res = sorted_list[head][1] + sorted_list[tail][1] #用来判断与target的关系    while res != target:        if res &gt; target: # 和比target大说明tail的值大了，tail向前移动            tail -= 1        if res &lt; target: # 和比target小说明head的值小了，head向后移动            head += 1        res = sorted_list[head][1] + sorted_list[tail][1] # 每次移动完成后更新res    return [sorted_list[head][0], sorted_list[tail][0]]\n\n 第二种:\n class Solution:def twoSum(self, nums: List[int], target: int) -&gt; List[int]:    sorted_index=sorted(range(len(nums)),key = lambda x:nums[x]) # 排序nums，返回的索引序列    head = 0    tail = len(nums) - 1    res = nums[sorted_index[head]] + nums[sorted_index[tail]] # sorted_index[head]其值对于nums索引位置    while res != target:        if res &gt; target:            tail  -= 1        if res &lt; target:            head += 1        res = nums[sorted_index[head]] + nums[sorted_index[tail]]    return [sorted_index[head],sorted_index[tail]]\n\n34.在排序数组中寻找元素的第一个和最后一个位置\n类二分查找类似于二分查找，找到第一个等于target的位置，记录后，再继续找到大于target的第一个位置记录，则这区间为所求，关键在于:边界控制条件。由于边界控制不好，导致代码无法运行，看了评论区代码后，依照写了两个函数searchleft和searchright分别查找左边界和有边界；后面看到另一位大神的代码后，发现可以更加简洁，只需一个函数searchleft找到左边界后，右边界依旧使用searchleft，查找值为target+1找到后再将结果-1这样就找到了target的右边界，非常巧妙！\n class Solution:def searchRange(self, nums: List[int], target: int) -&gt; List[int]:    # 找到左边界    def SearchLeft(nums,target):        low=0        high=len(nums)-1        while low&lt;=high:            mid = (low+high)//2            # 判断条件必须加等号，防止漏掉元素            if nums[mid]&gt;=target:                high=mid-1            else:                low=mid+1        return low    # 找右边界    # def SearchRight(nums,target):    #     low=0    #     high=len(nums)-1    #     while low&lt;=high:    #         mid = (low+high)//2    #         if nums[mid]&gt;target:    #             high=mid-1    #         else:    #             low=mid+1    #     return high    # leftindex=SearchLeft(nums,target)    # rightindex=SearchRight(nums,target)    # searchleft找到的是第一个&gt;target+1的数，数组是有序的；-1后即为target的右边界值    leftindex=SearchLeft(nums,target)    rightindex = SearchLeft(nums,target+1)-1    if leftindex&lt;=rightindex:        return [leftindex,rightindex]    else:        return [-1,-1]\n\n242.有效字母的异位词\n用数组记录出现字符串的个数，在比较数组定义一个数组arr初始化为0.用来记录s中字符出现的个数，利用ord()函数，将s中每个字符转换为Unicode值，再在数组相应位置+1操作，遍历s，这样就记录了s中所有字符出现的个数。同样再遍历t，不过这次数组再相应位置进行-1操作，如果两个字符串所含字符个数是相等的，那么arr数组应该为0，若不为0则不等，代码:\nclass Solution: def isAnagram(self, s: str, t: str) -&gt; bool:     # 判断s 和 t 的长度是否相等     if (len(s)==len(t)):         arr = [0] * 26 # 初始化数组用来记录 s 中出现字符的个数         for i in s:             arr[ord(i)-ord(&#x27;a&#x27;)]+=1         for j in t:             arr[ord(j)-ord(&#x27;a&#x27;)]-=1 # 若出现相同的字符贼减一         # 判断arr数组是否为空         for i in range(26):             if arr[i]!=0:                 return False         return True     else:         return False\n\ndefaultdictdefaultdict是python中的一个内置字典子类，重载了一个方法来实现默认值的设定。在创建defaultdict对象，需要提供一个参数作为默认值或者一个函数用来生成默认值。\nclass Solution:def isAnagram(self, s: str, t: str) -&gt; bool:    from collections import defaultdict    sdict=defaultdict(int)    tdict=defaultdict(int)    for i in s:        sdict[i]+=1    for j in t:        tdict[j]+=1    if sdict==tdict:        return True    else:        return False\n\n202.快乐数\n转为字符串计算平方，然后判断是否循环我一开始是想先把给的数字每次队10取余然后平方加起来，后面发现python可以更简单的实现这一步，就是把给的n转化为字符串然后遍历字符串将每次遍历的字符转换为int在平方相加，然后再定义一个列表，大小为n，将每次替换后的结果存入这个列表中，若此后的遍历出现了和列表中一样的数，那么这个数就不是快乐数，若循坏到1则为快乐数，代码如下:\n class Solution:    def Caculate_Pow(self,num:int) -&gt; int:        n = 0 #用来返回的值        # 将n变为字符串遍历再变为int求平方和        for i in str(num):            n += int(i)**2        return n    def isHappy(self,n:int) -&gt; bool:        ret = [n] #设置一个n大小的列表用来判断是否出现了循环        while n!=1:            n=Caculate_Pow(n)            if n in ret:                return False            else:                ret.append(n) # 若未出现再ret中且不等于1时，将其加入到ret中        return True\n\n454. 四数相加 II\n哈希表+分治这题没思路，做不出，听了老师的讲解，由题所给条件nums1[i] + nums2[j] + nums3[k] + nums4[l] &#x3D;&#x3D; 0 –&gt; nums1[i] + nums2[j] &#x3D; - nums3[k] - nums4[j] 所以我们可以分别处理nums1 2 和nums3 4 并且定义两个字典dic_A 和 dic_B 分别记录两个数组组合的值和次数。再判断dic_A和中与dic_B相同的值，并且将两者出现的次数相乘，因为是组合问题所以应该是相乘而不是相加代码示例如下:\nclass Solution:def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -&gt; int:    dic_A = &#123;&#125;    dic_B = &#123;&#125;    res = 0    # 先求两个的交集    #nums1[i] + nums2[j]  == - nums3[k] - nums4[l]    for i in nums1:        for j in nums2:            sum_ij = i + j            dic_A[sum_ij] = dic_A.get(sum_ij,0) + 1 # 记录sum_ij出现的次数        for k in nums3:        for l in nums4:            sum_kl = -k-l            dic_B[sum_kl] = dic_B.get(sum_kl,0) + 1        # 如果dic_A和dic_B有交集，他们次数乘积累加后为所求，注意这是组合问题，不能相加    for item in dic_A.items():        if item[0] in dic_B:            res += item[1] * dic_B[item[0]]    return res\n\n344. 反转字符串\n双指针原地逆转设置双指针i,j一个指向头部，一个指向尾部，再用tmp当中间变量交换，当i&gt;&#x3D;j时完成交换。\nclass Solution:def reverseString(self, s: List[str]) -&gt; None:    &quot;&quot;&quot;    Do not return anything, modify s in-place instead.    &quot;&quot;&quot;    i = 0    j = len(s) - 1    while i&lt;=j:        tmp = s[j]        s[j] = s[i]        s[i] = tmp        i += 1        j -= 1\n\n876. 链表的中间结点\n快慢指针设置快慢指针，慢的为slow，快的为fast，慢的一次走一步，快的一次走两步，当fast走到末尾时，slow处于中间位置\n# Definition for singly-linked list.# class ListNode:#     def __init__(self, val=0, next=None):#         self.val = val#         self.next = nextclass Solution:    def middleNode(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        if head == None:            return None        slow = head        fast = head        while fast and fast.next:            slow = slow.next            fast = fast.next.next        return slow\n\n206.反转链表\n双指针+临时变量记录我这里是重新返回了一个新的链表，按照头插法遍历原链表，就完成了链表的反转\n# Definition for singly-linked list.# class ListNode:#     def __init__(self, val=0, next=None):#         self.val = val#         self.next = nextclass Solution:    def reverseList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        # 链表为空直接返回        if head == None:            return head        # i指针遍历head链表        i = head        NewNode = None        # j指针指向新的链表        j = NewNode        # 头插法实现逆转        while i!= None:            tmp = i.next            i.next = j            j = i            i = tmp        return j        \n\n160. 相交链表\n先判断长度，然后从位置相同的结点同时遍历，找相同的结点先计算后两个链表的长度，然后利用一个变量计算差值，让长的那个链表与短的那个链表同时向后遍历，找到相同的结点\n# Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    # 计算链表的长度    def get_length(self,head:ListNode) -&gt; int:        count = 0        i = head        while i:            count += 1            i = i.next        return count    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; Optional[ListNode]:        m = self.get_length(headA)        n = self.get_length(headB)        node_headA = headA        node_headB = headB        判断哪个链表长，记录差值，然后让长的链表先走，保证两个链表能在同一个位置向后遍历        if m &gt; n:            cha = m - n            i_headA = 0            while i_headA &lt; cha:                node_headA=node_headA.next                i_headA += 1        else:            cha = n - m            i_headB = 0            while i_headB &lt; cha:                node_headB=node_headB.next                i_headB += 1        # 如果遍历到相同的结点返回        while node_headA and node_headB:            if node_headA == node_headB:                return node_headA            node_headA = node_headA.next            node_headB = node_headB.next        return None\n\n20.有效的括号一开始我是想记录每个字符出现的次数然后判断是否为奇数，当然通过不来，因为没要考虑到顺序问题，”([)]”这个测试用例就会失败\n\n使用replace()替换字符设置判断条件，遇到’{}’,’[]’,’()’,直接替换为空字符\nclass Solution:def isValid(self, s: str) -&gt; bool:    while &#x27;&#123;&#125;&#x27; in s or &#x27;()&#x27; in s or &#x27;[]&#x27; in s:        s=s.replace(&#x27;&#123;&#125;&#x27;,&#x27;&#x27;)        s=s.replace(&#x27;[]&#x27;,&#x27;&#x27;)        s=s.replace(&#x27;()&#x27;,&#x27;&#x27;)    return s==&#x27;&#x27;\n\n哈希+栈K神解答;先创建一个包含所需字符的字典dic，然后再定义一个stack数组用来模拟栈操作，遍历s看字符是否存在于dic中，若存在入栈(查找左括号的过程),当遍历到不是左括号的时候出栈，看出栈的元素与当前元素是否匹配，若不匹配直接返回False，需要注意的是，stack初始时应该添加一个变量进去，同理在dic中添加一个不属于s的字符，最后判断stack长度为1时，返回True\n class Solution:def isValid(self, s: str) -&gt; bool:    dic = &#123;&#x27;[&#x27;:&#x27;]&#x27;,&#x27;(&#x27;:&#x27;)&#x27;,&#x27;&#123;&#x27;:&#x27;&#125;&#x27;,&#x27;a&#x27;:&#x27;a&#x27;&#125;    stack = [&#x27;a&#x27;]    for i in s:        if i in dic:            stack.append(i)        elif dic[stack.pop()] != i:            return False    return len(stack) == 1\n\n496. 下一个更大元素 I\n由题可知nums2包含了nums1，因此可以用index查找nums1中数在nums2中的下标，然后再判断从该处起是否有大于nums1的数，若有则赋值到nums1的相应位置，若没有则将nums1相应位置设置为-1\nclass Solution:def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:    for i in range(len(nums1)):        index = nums2.index(nums1[i]) + 1 # 查找nums1中的值再nums2中的位置，加一代表下一位        flag = 0 # flag用来判断nums2中是否有符合条件的数        while index &lt; len(nums2):            if nums2[index] &gt; nums1[i]: # nums2的右边有大于nums1的数                nums1[i] = nums2[index] # 将第一个大于的数赋值到nums1相应的位置                flag = 1                break            index += 1        if flag == 0:            nums1[i] = -1    return nums1\n\n字典+双循环(同学解答) 其实这种方式和我自己用index方式找下标本质上是一样的，不过这是用到了双循环，从nums2中去找第一个大于nums当前位置上的数。具体实现是:\n\n\n\n1.先初始化结果数组为-1 长度为nums1的长度 2.然后将nums2中的数字和下标存入到字典当中 3.遍历nums1，同时遍历nums2从nums1当前值在nums2中的下标开始往后找，若找到一个比nums1此时位置上的数大的数后将其赋值到结果数组\n\n\n\n class Solution:def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:    ans = [-1] * len(nums1)    dic = &#123;&#125;    # 将nums2的数字和下标存入字典    for item in range(len(nums2)):        dic[nums2[item]] = item    # 遍历nums1 在nnums2中从nums1当前数字的下标往后找若有大于nums1的就赋值放入ans中    for i in range(len(nums1)):        for j in range(dic[nums1[i]],len(nums2)):            if nums2[j] &gt; nums1[i]:                ans[i] = nums2[j]                break # 找到一个就结束当前循环    return ans\n\n字典+栈(同学解答) 这个方法采用的是将nums2中存在后一个数大于前一个数的存入到字典中，key为待查找数，value为向后第一个大于key的数。当遍历完nums2后，从nums1开始遍历，并查找dic中是否存在该数，存在将其放到待放回数组中，具体代码实现:\n class Solution:def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:    stack = []    dic = &#123;&#125;    res = []    for i in range(len(nums2)):        # 当栈不为空，并且nums2[i]大于栈顶元素时，更新字典        while stack and stack[-1]&lt;nums2[i]:            dic[stack.pop()] = nums2[i]        stack.append(nums2[i]) # 更新栈顶、    # 在nums2中查找nums1    for i in nums1:        res.append(dic.get(i,-1))    return res\n\n150. 逆波兰表达式求值\n使用栈来计算定义一个栈，设置条件判断，是运算符号就出栈，计算后后再入栈，这里注意的是在计算正数与负数相除时，要使用int进行取整，不能用 &#x2F;&#x2F; 进行整除。再进行减法和除法运算时要先用一个临时变量记录出栈的数据，再用用出栈的数减去或者除以这个临时变量，遍历tokens计算得到最后的结果\nclass Solution:def evalRPN(self, tokens: List[str]) -&gt; int:    if len(tokens) == 1:        return int(tokens[0])    stack = []    res = 0    for i in tokens:        if i != &#x27;+&#x27; and i != &#x27;-&#x27; and i != &#x27;/&#x27; and i != &#x27;*&#x27;:            stack.append(int(i))        elif i == &#x27;+&#x27;:            res = stack.pop() + stack.pop()            stack.append(res)        elif i == &#x27;-&#x27;:            temp = stack.pop() # 减数            res = stack.pop() - temp            stack.append(res)        elif i == &#x27;*&#x27;:            res = stack.pop() * stack.pop()            stack.append(res)        elif i == &#x27;/&#x27;:            tmp = stack.pop() # 除数            res = int(stack.pop()/tmp)            stack.append(res)    return res\n\nLC官方解答(栈)\nclass Solution:    def evalRPN(self, tokens: List[str]) -&gt; int:        op_to_binary_fn = &#123;            &quot;+&quot;:add,            &quot;-&quot;:sub,            &quot;*&quot;:mul,            &quot;/&quot;:lambda x,y:int(x/y),        &#125;        stack = list() # 定义栈        for token in tokens:            try:                num = int(token) # 不是操作符            except ValueError: # 遇到操作符执行相应的操作                num2 = stack.pop()                num1 = stack.pop()                num = op_to_binary_fn[token](num1,num2) # 注意num1和mum2的位置，先出栈的作为除数            finally:                stack.append(num)        return stack[0] # 最后的运算结果\n\n347. 前 K 个高频元素\n排序+字典先将原数组排好序，再统计每个数字出现的次并将其存入到字典dict_nums中，再将dict_nums按照出现的次数来进行排序，最后将前k个赋值到list_r中即可\n\n\n代码如下\n\n\n\nclass Solution:def topKFrequent(self, nums: List[int], k: int) -&gt; List[int]:    # 用来返回结果的列表    list_r = []    # 存放每个数字及出现的次数    dict_nums = &#123;&#125;    # 记录每个数字出现的次数    cnt = 0    # 先排序    nums = sorted(nums)    # 将每个数字出现的次数记录到dict_nums    tmp = nums[0]    i = 0    while i &lt; len(nums):        if nums[i] == tmp:            cnt += 1        if nums[i] != tmp:            dict_nums[nums[i - 1]] = cnt            cnt = 1            tmp = nums[i]        i += 1    i = 0    # 记录最后一个数字的出现次数    dict_nums[nums[len(nums) - 1]] = cnt    # 如果原数组不止一个数的话，按照值的大小来排序字典    if len(dict_nums) &gt; 1:        new_dict = sorted(dict_nums.items(), key=lambda x: x[1],reverse=True)        new_dict = dict(new_dict)    else:        new_dict = dict_nums    # 将原数组中出现次数前k的赋值到list_r    for key, val in new_dict.items():        if i &lt; k:            list_r.append(int(key))            i += 1    return list_r\n\n","categories":["力扣"],"tags":["刷题","python"]}]