[{"title":"Jupyter_Command","url":"/2023/05/12/Jupyter-Command/","content":"Jupyter常用的命令命令模式下常用指令\nm键，可以直接输入markdown格式的内容，y键可以回到代码格式\nShift+回车 运行当前代码块\nCtrl+回车 只运行当前代码块\nAlt+回车 运行当前代码块并向下新建一个代码块\n按b向下新建一个代码块\n按a向上新建一个代码块\n按c复制当前代码块\n按x剪切当前代码块\n按v粘贴当前代码块；shift+v,粘贴到上一个代码块\n按z撤回操作\n按dd两次删除代码块\n\n","categories":["笔记"],"tags":["jupyter notebook","python"]},{"title":"MarkDown语法","url":"/2023/06/04/MarkDown%E8%AF%AD%E6%B3%95/","content":"这是一级标题这是二级标题这是三级标题换行的话在末尾打两个空格然后回车就能换行\n斜文字 ctrl+i文字加粗 ctrl+b  \n插入图片直接复制进来就可以  \n表格\n\n\n大明\n小明\n小红\n\n\n\n101\n21\n23\n\n\n冒号在哪边就往哪边对齐\n\n\n\n\n链接这是一个链接\ncodeprintf(&quot;hello world&quot;);\n\n\n实心点\n\n","categories":["MarkDown"],"tags":["语法"]},{"title":"Linux命令","url":"/2023/05/26/Linux%E5%91%BD%E4%BB%A4/","content":"Linux常用指令\n获取登录信息 -w &#x2F;who &#x2F;last &#x2F;lastb\n查看自己使用的 -Shell -ps\n查看命令的说明和位置 -whatis &#x2F;which &#x2F;whereis\n清除屏幕上的内容 -clear\n看帮助文档 -man&#x2F;info &#x2F;–help &#x2F;apropos\n查看系统和主机名 -uname &#x2F;hostname\n时间和日期 -date &#x2F;cal\n重启和关机 -reboot &#x2F;shutdown\n\n文件和文件夹操作\n创建&#x2F;删除空目录 -mkdir &#x2F;rmdir\n\n创建&#x2F;删除文件 -touch &#x2F;rm\n\ntouch命令用于创建空白文件或修改文件时间。在linux系统中一个文件有三种时间\n更改内容的时间 -mtime\n更改权限的时间 -ctime\n最后访问时间 -atime\n\n\nrm的几个重要参数    -i 交互式删除，每个删除项目都会进行询问  -r 删除目录并递归的删除目录中的文件和目录    -f 强制删除，忽略不存在的文件，没有任何提示\n\n切换和查看当前工作目录 -cd &#x2F;pwd\n\n快捷键 运行结果\ncd 更改工作目录到home。\ncd - 更改工作目录到先前的工作目录。\ncd ˜user_name 更改工作目录到home目录。例如, cd ˜bob 会更改工作目录到用“b录。\n\n\n\n\n查看目录内容 -ls -l 以长格式查看文件和目录 -a 显示以点开头的文件（隐藏文件） -R 遇到目录要进行递归展开(继续列出目录下面的文件和目录) -d 只列出目录，不列出其他内容 -S &#x2F;-t 按大小&#x2F;时间排序\n\n查看文件内容 -cat &#x2F; tac &#x2F; head &#x2F; tail &#x2F; more &#x2F; less &#x2F; rev &#x2F; od\n\n拷贝&#x2F;移动文件 - cp &#x2F; mv\n\n文件重命名 -rename\n\n查找文件和查找内容 -find &#x2F; grep \n\ngrep在搜索字符串是可以使用正则表达式，如果需要使用正则表达式可以用grep -E 或者直接使用egrep\n\n\n创建链接和查看链接 ln 具体语法:\n\n\nln [选项] [源文件] [链接]\n\n\n系统命令\npsps -ef表示显示所有进程，ps -ef|grep其中grep表示筛选包含特定关键词\n\nshell命令\n复制文件和目录 scp 命令scp是linux系统下基于ssh登录进行安全的远程文件拷贝指令；scp是加密的，rcp是不加密的，sco是rcp的加强版，简易语法如下：\nscp [可选参数] file_source file_target\n\n\n\n\n","categories":["笔记"],"tags":["Linux"]},{"title":"Python随笔","url":"/2023/06/03/Python%E9%9A%8F%E7%AC%94/","content":"Python的一些不熟悉的知识一些小知识，想到什么写什么\n列表与数组\n\npython中的列表可以包含不同类型的元素，如字符串、整数、浮点数等，而数组通常包含相同类型的元素\npython中列表是动态数组，可以自动调整大小，而数组再创建时需要指定大小，一旦创建后，大小就不能再改变，因此在插入或删除元素时需要手动。\n数组相当于列表来说在访问元素时性能更好，以为列表是动态数组插入或删除元素可能会有些性能损失。\n\n\n元组元组是一个集合是有序的和不可改变的元组使用小括号(),列表使用方括号[]元组的创建很简单，只需要在括号中添加元素，使用逗号隔开即可\n\n集(Set)集合是无序和无索引的集合，可以用来快速判断一个元素是否在某个集合中，在py中用{}表示\n\n添加一个项目到集合用add()\n thiset=&#123;&quot;apple&quot;,&quot;banana&quot;,&quot;cherry&quot;&#125;thiset.add(&quot;orange&quot;)\n\n添加多个项目用update()\n   thiset=&#123;&quot;apple&quot;,&quot;banana&quot;,&quot;cherry&quot;&#125;thiset.update([&quot;orange&quot;, &quot;mango&quot;, &quot;grapes&quot;])\n\n删除用Remove()或discard()方法  如果删除的项目不存在，remove()会引发错误，而discard()不会引发错误\n\npop()删除最后一项\n\nclear()清空集合 …\n\n\n\n字典\n\n使用values()函数返回字典的值\n for x in thisdict.values():  print(x)\n\n使用items()循环遍历键和值\n for x,y in thisdict.items():  print(x,y)\n\ndict()创建字典\n epdict = dict()print(epdict) # 输出&#123;&#125;print(len(epdict)) # 输出0print(type(epdict)) # &lt;class &#x27;dict&#x27;&gt;\n\n\n字典的访问\n使用中括号[ ]  \n dic = &#123;&#x27;key1&#x27;: &#x27;value1&#x27;, &#x27;key2&#x27;: &#x27;value2&#x27;, &#x27;key3&#x27;: &#x27;value3&#x27;&#125;print(dic[&#x27;key1&#x27;])  # 输出 value1\n\n使用get( )方法  dic.get(key,default&#x3D;None)它用于从字典中获取指定键key对应的值，键不存在返回一个默认值deafult\n dic = &#123;&#x27;key1&#x27;: &#x27;value1&#x27;, &#x27;key2&#x27;: &#x27;value2&#x27;, &#x27;key3&#x27;: &#x27;value3&#x27;&#125;print(dic.get(&#x27;key1&#x27;)) # 输出value1print(dic.get(&#x27;key4&#x27;)) # 输出 None\n\n除以上外，可以通过keys(),values()和items()方法获取字典中所有的键、值和键值对。例如:\n dic = &#123;&#x27;key1&#x27;: &#x27;value1&#x27;, &#x27;key2&#x27;: &#x27;value2&#x27;, &#x27;key3&#x27;: &#x27;value3&#x27;&#125;print(dic.keys()) # 输出 dict_keys([&#x27;key1&#x27;, &#x27;key2&#x27;, &#x27;key3&#x27;])print(dic.values()) # 输出 dict_values([&#x27;value1&#x27;, &#x27;value2&#x27;, &#x27;value3&#x27;])print(dic.items()) # dict_items([(&#x27;key1&#x27;, &#x27;value1&#x27;), (&#x27;key2&#x27;, &#x27;value2&#x27;), (&#x27;key3&#x27;, &#x27;value3&#x27;)])\n\n 注意:keys()、values()、items()方法返回的是一种特殊的视图对象，而不是普通的列表。要转换成列表可以用list()函数\n\n\n\n\n\n频率看到计算频率等问题直接联想到以下代码:\nfor i in nums:  dic[i] = dic.get(i,0) + 1\n\n解包解包是指将一个序列或元组中的元素分别赋值给变量。可迭代对象是指可以被迭代器遍历的对象，例如列表、元组、字符串等。而解包则是指将一个序列或元组中的元素分别赋值给多个变量的操作。\n\n取整使用int取整大于0的数向下取整，小于0的数向上取整\n\n匿名函数  lambda函数是个匿名函数，可以使用任意数量的参数，但是只有一个表达式。\n\n用法\n\nlambda arguments:expression# ep1.返回一个加10的数x=lambda a:a+10# ep2.可以使用任意数量的参数：x=lambda a,b,c:a+b+cprint(x(1,2,3))\n\n迭代器列表、元组、字典都是可迭代的对象，对于这些对象都有一个获取迭代器iter()方法\nmytuple = (&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;)myit = iter(mytuple)print(next(myit))print(next(myit))print(next(myit))\n\n创建一个返回数字的迭代器\nclass MyNumbers:  def __iter__(self):    self.a=1    return self  def __next__(self):    x=self.a    self.a +=1    return xmyclass = MyNumbers()myiter = iter(myclass)print(next(myiter))print(next(myiter))print(next(myiter))print(next(myiter))print(next(myiter))\n\nStoplteration关键字如果有足够的next()语句，为了防止迭代继续进行，可以使用StopIteration语句ep1迭代20次后停止\nclass MyNumbers:  def __iter__(self):    self.a=1    return self    def __next__(self):    if self.a &lt;= 20      x = self.a      self.a += 1      return x    else:      raise StopIterationmyclass = MyNumbers()myiter = iter(myclass)for x in myiter:  print(x)\n\nself在python中,self是一个惯用的参数名称。在定义一个类的方法时，需要将self作为第一个参数传递给方法，当我们定义一个类的方法时，那么在调用该方法时，实际上是通过类的实例对象来调用这个方法，因此不需要显式传递self参数；如果我们在类的方法中访问类的属性或者方法，那么必须使用self来访问(self.func)。如果我们在方法中直接访问属性或者方法，py会解释为局部变量或函数，从而导致错误。\n\n运算符\n\n&#x2F;&#x2F; –&gt; 取整数-往小的方向取整数ep\n\n\n9&#x2F;&#x2F;24\n\n\n\n\n** –&gt; 幂 返回x的y次幂\n逻辑运算符\n\n\n与 and –&gt; x and y\n或 or  –&gt; x  or y\n非 not –&gt; x not y\n\n\n二维数组初始化\n  # 创建一个rows行cols列的二维数组，初始值为0matrix = [[0 for _ in range(cols)] for _ in range(rows)]# 创建一个rows行cols列的二维数组，初始值为matrix = [[0] * cols for _ in range(row)]\n\n字符串格式化例子:\nname = &quot;张三&quot;age = 18print(&quot;我叫%s，今年%d岁。&quot; % (name, age)) # 输出: &quot;我叫张三，今年18岁。&quot;\n\ntrytry和except语句来处理异常，try语句块用于包裹可能会引发异常的代码，而except来处理可能引发的异常，除此之外还可以使用else和finally语句块来进一步处理异常。else语句块中的代码会在try语句块中没有发生异常时执行，而finally语句中的代码无论是否发生异常都会执行。\ntry:  x = 10 / 2except ZeroDivisionError:  print(&quot;除数不能为零&quot;)else:  print(&quot;结果为:&quot;, x)finally:  print(&quot;无论是否发生异常，都会执行这里的代码&quot;)\n\nexcept异常由以下几种:\n  Exception：所有异常的基类，可以捕获任何类型的异常。ZeroDivisionError：除以零时引发的异常。TypeError：类型不匹配时引发的异常。ValueError：值不合法或无效时引发的异常。IndexError：索引超出范围时引发的异常。KeyError：字典中使用不存在的键时引发的异常。FileNotFoundError：打开或读取文件时找不到文件时引发的异常。NameError：尝试访问不存在的变量或函数时引发的异常。ImportError：导入模块失败时引发的异常。IOError：输入/输出操作失败时引发的异常。\n\n推导式用于快速创建列表、字典、集合等可迭代对象，一般有以下几种:\n\n列表推导式 语法形式计为:[expression for item in iterable if condition]或者[expression for item in iterable] 示例:\n\n过滤长度小于或者等于3的字符串列表，并将剩下的转换成大写字母:\n\n names = [&#x27;Bob&#x27;,&#x27;Tom&#x27;,&#x27;alice&#x27;,&#x27;Jerry&#x27;,&#x27;Wendy&#x27;,&#x27;Smith&#x27;]new_names = [name.upper()for name in names if len(name)&gt;=3]print(new_names)# 输出[&#x27;ALICE&#x27;, &#x27;JERRY&#x27;, &#x27;WENDY&#x27;, &#x27;SMITH&#x27;]\n\n字典推导式  语法形式为:{key_expr:value for value in collction} 或者 {key_expr:value for value in collction if condition}  示例:\n\n使用字符串及其长度创建字典\n\n  listdemo = [&#x27;Google&#x27;,&#x27;Runoob&#x27;, &#x27;Taobao&#x27;]newdic = &#123;key:len(key) for key in listdemo&#125;newdic# 输出&#123;&#x27;Google&#x27;: 6, &#x27;Runoob&#x27;: 6, &#x27;Taobao&#x27;: 6&#125;\n\n集合推导式 语法形式为:{expression for item in Sequence} 或者 {expression for item in Sequence if condition} 示例:\n\n判断不是abc的字母并输出\n\n a = &#123;x for x in &#x27;abracadabra&#x27; if x not in &#x27;abc&#x27;&#125;a# 输出 &#123;&#x27;d&#x27;,&#x27;r&#x27;&#125;type(a)# 输出 &lt;class &#x27;set&#x27;&gt;\n\n元组推导式(生成器表达式) 可以利用range区间、元组、列表、字典和集合等数据结构类型，快速生成一个满足指定需求的元组，语法形式为:(expression for item in Sequence) 或者 (expression for item in Sequence if condition)\n\n\n\n元组推导式和列表推导式用法完全相同，只是元组推导式是用()圆括号,列表推导式是用[]中括号，类外元组推导式返回的结果也是一个生成器对象 示例:\n\n\n\n\n生成一个包含数字1-9的元组：\n\n a= (x for x in range(1,10))a# &lt;generator object &lt;genexpr&gt; at 0x7faf6ee20a50&gt; 返回是是生成器对象tuple(a)# 转换为元组 (1, 2, 3, 4, 5, 6, 7, 8, 9)\n\n\nstack下标问题正数索引(从0开始)，列表元素的顺序从左到右。而对于负数索引(从-1开始),元素顺序是从右到左；相当于一个是入栈一个是出栈\n\n\npy函数\nremove()用于从列表中删除指定元素；语法格式为: list_name.remove(element) #element 任意数据类型\n\n删除普通类型元素  删除列表中存在的数字或者字符串;不存在会报错，引发valueError异常\n list1 = [&#x27;zhangsan&#x27;, &#x27;lisi&#x27;, 1, 2]list1.remove(1)list1.remove(&#x27;lisi&#x27;)\n\n删除对象类型元素  \n list1=[1,2,[3,4],(5,6)]a=[3,4]b=(5,6)list1.remove(a) # 删除列表类型list1.remove(b) # 删除元组类型\n\n删除多个元素，可以使用循环来实现\n # 创建一个列表fruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;, &quot;peach&quot;, &quot;banana&quot;, &quot;kiwi&quot;]# 删除所有的 &quot;banana&quot; 元素while &quot;banana&quot; in fruits:    fruits.remove(&quot;banana&quot;)print(fruits)  # [&quot;apple&quot;, &quot;orange&quot;, &quot;peach&quot;, &quot;kiwi&quot;]\n\n 注意:在使用 remove() 函数时要谨慎，特别是在迭代列表的过程中,当删除一个元素后会导致后面的元素索引发生变化从而可能导致发生错误\n\nenumerate()enumerate()是python中的一个内置函数，将一个可迭代对象转换为一个枚举对象，同时返回每个元素的索引和值，常用于for循环中获取中获取每个元素的位置信息。用法: enumerate(iterable,start&#x3D;0)其中，iterable表示要枚举的可迭代对象，start表示起始索引\n\nord()ord()是一个内置函数，用于获取给定字符的Unicode码点值，ord()函数接受单个字符作为参数；\n  ord(&#x27;a&#x27;) # 返回97  ```  - defaultdict()  defaultdict是python中的一个内置字典子类，重载了一个方法来实现默认值的设定。在创建defaultdict对象，需要提供一个参数作为默认值或者一个函数用来生成默认值。  比如有一个字典对其中的值进行累加操作，如果某个键不存在，则将其值设置为0，使用defaultdict可以避免手动判断键是否存在的过程:  ```python  from collections import defaultdict  d = defaultdict(int)  # 对字典中的值进行累加操作  for i in &#x27;mississippi&#x27;：    d[i]+=1  print(d) # 输出：defaultdict(&lt;class &#x27;int&#x27;&gt;, &#123;&#x27;m&#x27;: 1, &#x27;i&#x27;: 4, &#x27;s&#x27;: 4, &#x27;p&#x27;: 2&#125;)\n\nsorted()返回一个新的排好序的列表，而不改变原始列表例如有一个数字列表\nnum = [4, 2, 7, 1, 3]\n\n我们可以使用sorted()进行排序、会返回一个新的列表，但是排序后会改变数字原有的索引值\n  sorted_list = sorted(nums)\n\n若不想改变原数组的索引值可以用以下方法\n  # 对nums的元素进行排序，排序的依据是nums中对应的位置，对于nums中的每个元素k，使用nums[k]的值作为排序关键字sorted(nums,key=lambda k:nums[k]])# 使用enumerate()生产一个包含元素索引和值的可迭代对象，按照值进行排序，不改变原有元素的索引值sorted_nums = soreted(enumerate(nums),key=lambda x:x[1])\n\n对于上述第二种方法，enumerate(nums)会返回一个(index,value)的元组.  \n\nlist()list()是一个空列表的构造函数。当调用list()时，它会返回一个空列表[]。这个空列表可以用来存储任意类型的元素，并且可以根据需要进行修改、添加或删除元素。\n\n基本数据结构操作\npython建立二叉树(递归)\n\n","categories":["Python"],"tags":["基础知识"]},{"title":"Hello World","url":"/2023/05/26/hello-world/","content":"hexo添加新文章hexo new post filename编辑你的文件hexo g -d //完成推送到GitHub就行","categories":["hello"],"tags":["Hello World"]},{"title":"git_merge笔记","url":"/2023/04/06/git-merge%E7%AC%94%E8%AE%B0/","content":"gitub问题:master和main分支合并问题:github创建仓库后默认分支是main，而本地创建的是master\n\n先给本地master改名\ngit branch -M main//-M对分支重命名\n\n查看所有分支\n git branch -a* main   remotes/origin/main   remotes/origin/master  \n\n删除远程分支master\n  $ git push origin --delete master To https://github.com/     - [deleted]         master  \n\n确认删除情况\n$git branch -a* mainremotes/origin/main\n\n切换当前分支main，也就要保留下来的分支\n $ git checkout main Already on &#x27;main&#x27; \n\n合并分支\n $ git merge remotes/origin/main fatal: refusing to merge unrelated histories \n\n 说明:拒绝合并，需要忽略这个限制，添加”–allow–unrelated-histories”\n\n提交修改\ngit push origin main\n\n","categories":["随笔"],"tags":["git"]},{"title":"python利用列表实现队栈操作","url":"/2023/08/24/python%E5%88%A9%E7%94%A8%E5%88%97%E8%A1%A8%E5%AE%9E%E7%8E%B0%E9%98%9F%E6%A0%88%E6%93%8D%E4%BD%9C/","content":"使用列表实现队列和栈操作\n栈栈是一种后进先出的数据结构，在python中可以使用列表来实现一些相关操作\nstack = [] # 创建一个栈# 入栈操作stack.append(1)stack.append(2)stack.append(3)# 出栈操作num = stack.pop()print(&quot;出栈元素:&quot;,num)print(&quot;更新后的栈:&quot;,stack)\n\n\n\n\n程序输出出栈元素:3更新后的栈:[1,2]\n\n\n\n\n队列队列是一种先进先出的数据结构，同理也可以使用列表来实现\nqueue = [] # 创建一个队列# 入队操作queue.append(1)queue.append(2)queue.append(3)# 出队操作num = queue.pop(0) #注意这里和栈不一样print(&quot;出队元素:&quot;,num)print(&quot;更新后的队列:&quot;,queue)\n\n\n\n\n输出出队元素:1更新后的队列:[2,3]\n\n\n\n\n\n使用collections模块来实现队列\n队列使用collections模块中的deque类来实现队列操作。deque是一个双端队列，支持在队列两端进行插入和删除操作。\n# 导入deque类from collections import deque# 创建一个空队列queue = deque()# 入队queue.append(1)# 出队element = queue.popleft()\n\n","categories":["python"],"tags":["python语法","栈和队列"]},{"title":"初识BigData-hadoop-hdfs-hvie","url":"/2023/10/23/%E5%88%9D%E8%AF%86BigData-hadoop-hdfs-hvie/","content":"node1:9870\n启动环境(要在 hadoop 用户下）# 1.启动hdfsstart-dfs.sh# 停止stop-dfs.sh# 2.启动yarnstart-yarn.sh# 3.启动历史服务器mapred --daemon start historyserver# 4.启动metastore(在hive目录下)#前台启动 bin/hive --service metastore#后台启动 nohup bin/hive --service metastore &gt;&gt; logs/metastore.log 2&gt;&amp;1 &amp;# 5.启动hive#直接写SQL bin/hive#可供其他客户端链接 bin/hive --service hiveserver2#hiveserver2后台启动 nohup bin/hive --service hiveserver2 &gt;&gt; logs/hiveserver2.log 2&gt;&amp;1 &amp;\n\n单独控制进程的启停。\n\n$HADOOP_HOME&#x2F;sbin&#x2F;hadoop-daemon.sh，此脚本可以单独控制所在机器的进程的启停\n 用法：hadoop-daemon.sh (start|status|stop)(namenode|secondarynamenode|datanode)\n\n$HADOOP_HOME&#x2F;bin&#x2F;hdfs，此程序也可以用以单独控制所在机器的进程的启停\n\n\n用法：hdfs –daemon (start|status|stop) (namenode|secondarynamenode|datanode)\n文件系统的操作命令Hadoop 提供了两套命令:\nhadoop(老版本),用法:hadoop fs\nhdfs（新版本),用法:hdfs dfs\n\n创建文件夹\nhadoop fs -mkdir [-p]  …\nhdfs dfs -mkdir [-p]  …\n​path​​为待创建目录\n​-p​​选项与 linux mkdir​​一致会沿着路径创建父目录\n\n查看指定目录下内容\n\nhadoop fs -ls [-h] [-R] […]\n\nhdfs dfs -ls [-h] [-R] […]\n​path​​指定目录路径\n​-h​​人性化显示文件 size\n​-R​​递归查看指定目录及其子目录\n\n\n\n上次文件到 HDFS 指定目录下\n\nhadoop dfs -put [-f] [-p]  … \n\nhdfs dfs -put [-f] [-p]  … \n​-f​​覆盖目标文件(已存在下)\n​-p​​保留访问和修改时间，(客户端所在机器）\n​dst​​目标文件系统\n\n\n\n查看 HDFS 文件内容\n\nhadoop fs -cat  …\n\nhdfs dfs -cat  …\nhadoop fs -cat /itcast/words.txthdfs dfs -cat /itcast/profile\n\n读取大文件可以使用管道符配合 more\n\nhadoop fs -cat  | more\n\nhdfs dfs -cat  | more\n\n\n\n下载 HDFS 文件\n\nhadoop fs -get [-f] [-p]  … \n\nhdfs dfs -get [-f] [-p]  … \n下载文件到本地文件系统指定目录，localdst 必须是目录\n​-f ​覆盖目标文件\n​-p ​保留访问和修改时间，所有权和权限\n\n\n\n拷贝 HDFS 文件\n\nhadoop fs -cp [-f]  … \nhdfs dfs -cp [-f]  … \n\n\n追加数据到 HDFS 文件中\n\nhadoop fs -appendTofile  … \n\nhdfs dfs -appendTofile  … \n将所有给定本地文件的内容追加到给定 dst 文件，若 dst 文件不存在，将创建该文件。如果 &lt;localSrc&gt; ​为 -​，则输入为从标准输入中读取。\n\n\n\nHDFS 数据移动操作\n\nhadoop fs -mv  … \n\nhdfs dfs -mv  … \n可以重命名\n\n\n\nHDFS 数据删除操作\n\nhadoop fs -rm -r [-skipTrash] URI [URI …]\n\nhdfs dfs -rm -r [-skipTrash] URI [URI …]\n​-skipTrash ​跳过回收站直接删除\n‍\n#&lt;property&gt;&lt;name&gt;fs.trash.interval&lt;/name&gt;&lt;value&gt;1440&lt;/value&gt;&lt;/property&gt;&lt;property&gt;&lt;name&gt;fs.trash.checkpoint.interval&lt;/name&gt;&lt;value&gt;120&lt;/value&gt;&lt;/property&gt;# 无需重启集群，在哪个机器配置的，在哪个机器执行命令就生效。回收站默认位置在：/user/用户名(hadoop)/.Trash\n\n\n\nHDFS 储存\nHDFS 副本块数量的配置\n可以在上传文件的时候，临时决定被上传文件以多少个副本存储\n​hadoop fs -D dfs.replication=2 -put test.txt /tmp/ ​如该命令，就可以在上传 test.txt ​文件时，临时设置其副本数为 2.\n对于已经存在 HDFS 的文件，修改 dfs.replication ​属性不会生效，可通过命令 hadoop fs -setrep [-R] 2 path ​将指定 path 的内容将会被修改为 2 个副本储存。-R ​选项表示对子目录也生效。\n\nfsck 命令检查文件的副本数\n​hdfs dfs path [-file[-blocks[-locations]]]​\n​-files ​可以列出路径内的文件状态\n​-files -blocks ​输出文件块报告(几个块，多少副本)\n​-files -blocks -locations ​输出每一个 block 的详情\n\n\nyarnnode1:8088\n\n启动 historyserver\n​mapred --daemon start historyserver​\n\n\nHIVEApache Hive 其 2 大主要组件就算:SQL 解析器以及元数据存储\n​​\nHive 架构图​​\n\n元数据存储\n存储在关系数据库如 mysql&#x2F;derby 中。Hive 中的元数据包括表的名字，表的列和分区及其属性，表的属性（是否为外部表等），表的数据所在目录等。Hive 提供了 Metastore 服务进程提供元数据管理功能\n\nDriver 驱动程序，包括语法解析器、计划编译器、优化器、执行器\n完成 HQL 查询语句从词法分析、语法分析、编译、优化以及查询计划的生成。生成的查询计划存储在 HDFS 中，并在随后有执行引擎调用执行。\n这部分内容不是具体的服务进程，而是封装在 Hive 所依赖的 Jar 文件即 Java 代码中。\n\n用户接口\n包括 CLI、JDBC&#x2F;ODBC、WebGUI。其中，CLI(command line interface)为 shell 命令行；Hive 中的 Thrift 服务器允许外部客户端通过网络与 Hive 进行交互，类似于 JDBC 或 ODBC 协议。WebGUI 是通过浏览器访问 Hive。\nHive 提供了 Hive Shell、 ThriftServer 等服务进程向用户提供操作接口\n\n启动 hive\n\n启动元数据管理服务(必须启动，在 hive 目录下启动)\n\n前台启动 bin/hive --service metastore​​\n后台启动 nohup bin/hive --service metastore &gt;&gt; logs/metastore.log 2&gt;&amp;1 &amp;​​\n\n\n启动客户端\n​Hive Shell方式(可以直接写SQL) bin/hive​​\n​​\n\n‍\n\n\n\n\nHive 使用语法数据库操作\n创建数据库\n​create database if not exists myhive;​ 创建名为 myhive 的数据库\n\n查看数据库详细信息\ndesc database myhive\n​​\n\n创建数据库并指定 hdfs 存储位置\n​create database myhive2 location &#39;user/hive/myhive2&#39;;​\n\n删除一个空数据库，如果数据库下有数据表，那么就会报错\n​drop database myhive;​​\n\n强制删除数据库\n​drop database myhive2 cascade;​​\n\n内部表（CREATE TABLE table_name ……）未被 external 关键字修饰的即是内部表， 即普通表。 内部表又称管理表,内部表数据存储的位置由 hive.metastore.warehouse.dir 参数决定（默认：&#x2F;user&#x2F;hive&#x2F;warehouse），删除内部表会直接删除元数据（metadata）及存储数据，因此内部表不适合和其他工具共享数据。\n\n外部表（CREATE EXTERNAL TABLE table_name ……LOCATION……）被 external 关键字修饰的即是外部表， 即关联表。外部表是指表数据可以在任何位置，通过 LOCATION 关键字指定。 数据存储的不同也代表了这个表在理念是并不是 Hive 内部管理的，而是可以随意临时链接到外部数据上的。所以，在删除外部表的时候， 仅仅是删除元数据（表的信息），不会删除数据本身。\n\n先创建外部表，然后移动数据刀 LOCATION 目录\n\n检查 hadoop fs -ls /tmp​，确认不存在 /tmp/test_ext1 ​目录\n创建外部表：create external table test_ext1(id int,name string) row format delimited fields terminated by &#39;\\t&#39; location &#39;/tmp/test_ext1&#39;;​\n​select * from test_ext1 ​空结果，无数据\n上传数据:hadoop fs -put test_external.txt /tmp/test_ext1/​\n​select * from test_ext1​，即可看到数据\n\n\n先存在数据，后创建外部表\n\n​hadoop fs -mkdir /tmp/test_ext2​\n​hadoop fs -put test_external.txt /tmp/test_ext2/​\n​create external table test_ext2(id int name string) row format delimited fields terminated by &#39;\\t&#39; location &#39;/tmp/test_ext2&#39;;​\n​select * from test_ext2;​\n\n\n\n数据在 HDFS 中以明文形式存在\n​​\n\n自定义分隔符\n​create table myhive.stu2(id int,name string)row format delimited fields terminated by &#39;\\t&#39;;​\n\n内外部表转换\n\n内转外\n​alter table stu set tblproperties(&#39;EXTERNAL&#39;=&#39;TRUE&#39;);​\n\n外转内\n​alter table stu set tblproperties(&#39;EXTERNAL&#39;=&#39;FALSE&#39;);​\n\n\n\nhive 表数据导出 -insert overwrite 方式\n\n语法 insert overwrite [local] directory &#39;path&#39; select_statement1 FROM from_statement;​\n\n将查询的结果导出到本地-使用默认分隔符\n​insert overwrite local diretory &#39;/home/hadoop/export1&#39; select  * from myhive.test_load;​\n\n将查询的结果导出到本地-指定分隔符\n​insert overwrite local directory &#39;/home/hadoop/export2&#39; row format delimited fields terminated by &#39;\\t&#39; select * from myhive.test_load;​\n\n将查询的结果导出到 HDFS 上(不带 local 关键字)\n​insert overwrite directory &#39;/tmp/export&#39; row format delimited fields terminated by &#39;\\t&#39; select * from myhive.test_load;​\n\n\n\n\n分区表可以把大的文件切割划分成一个个的小的文件，每次操作一个小的文件就会很容易\n​​​​\n基本语法:\n# 创建分区语法create table tablename(...) partitioned by (分区列 列类型,...) row format delimited fields terminated by &#x27;&#x27;;# 创建一个表带多个分区create table score2(s_id string,c_id string,s_score int) partitioned by (year string,month string,day string) row format delimited fields terminated by &#x27;\\t&#x27;;# 加载数据到分区表中load data local inpath &#x27;/export/server/hivedatas/score.txt&#x27; into table score partition (month=&#x27;202004&#x27;);# 加载数据到一个多分区的表中load data local inpath &#x27;/export/server/hivedatas/score.txt&#x27; into table score2 partition (year=&#x27;2020&#x27;,month=&#x27;04&#x27;,day=&#x27;01&#x27;);# 查看分区show partitions score;# 添加一个分区alter table score add partition (month=&#x27;202004&#x27;);# 同时添加多个分区 (添加分区之后就可以在hdfs文件系统当中看到表下面多了一个文件夹)alter table score add partition (month=&#x27;202004&#x27;) partition (month = &#x27;202005&#x27;);# 删除分区alter table score drop partition (month=&#x27;202006&#x27;);\n\n分桶表分桶和分区一样也是一种通过改变表的存储模式，从而完成对表优化的一种调优方式，但和分区不同，分区是将表拆分到不同的子文件夹中进行存储，而分桶是将表拆分到固定数量的不同文件中进行存储。\n\n分摊表创建\n开启分桶的自动优化 (自动匹配 reduce task 数量和桶数量一致)\nset hive.enforce.bucketing=true;# 创建分桶表create table course (c_id string,c_name string,t_id string) clustered by(c_id) into 3 buckets row format delimited fields terminated by &#x27;\\t&#x27;;\n\n分桶表数据加载\n桶表的数据加载，只能通过 insert select ​所以比较好的方法是:\n\n创建一个临时表，通过 load data ​加载数据进入表\n然后通过 insert select ​从临时表向桶表插入数据\n\n# 创建普通表create table course_common (c_id string,c_name string,t_id string) row format delimited fields terminated by &#x27;\\t&#x27;;# 普通表中加载数据load data local inpath &#x27;/export/server/hivedatas/course.txt&#x27; into table course_common;# 通过insert overwrite 给桶表加载数据insert overwrite table course select * from course_common cluster by(c_id);\n\n在创建分桶表时注意​ cluster 的写法:​\n\n为什么不可以用 load data ​必须用 insert select ​插入数据\n问题在于:如何将数据划分，划分的规则是什么?\n数据的划分是基于分桶列的值进行 hash 取模来决定的，由于 load data ​不会触发 MapReduce ​也就是没有计算过程，无法执行 Hash 算法，只是简单的移动数据而已，所以无法用于分桶表数据插入。\n\n性能提升\n分区表:在指定分区列的前提下，减少被操作的数据量，从而提示性能。\n分桶表:基于分桶列的特定操作，如:过滤、JOIN、分组、均可带来性能提升\n\n\n修改表操作\n表重命名\nalter table old_table_name rename to new_table_name;\n\n修改表属性值\nalter table table_name SET TBLPROPERTIES table_properties;# table_properties:(property_name = property_value,property_name = property_value,...)# ALTER TABLE table_name SET TBLPROPERTIES(&quot;EXTERNAL&quot;=&quot;TRUE&quot;);  修改内外部表属性# ALTER TABLE table_name SET TBLPROPERTIES (&#x27;comment&#x27; = new_comment); 修改表注释\n\n添加分区\n新分区添加了但是空的没数据，需要手动添加或上传数据文件\nalter table tablename add partition (month=&#x27;202002&#x27;);\n修改分区(修改元数据记录，HDFS 的实体文件夹不会改名但是在元数据中是改名了的,内部表会改，外部表不会改)\nalter table tablename partition (month = &#x27;202003&#x27;) rename to partition (month=&#x27;202202&#x27;);\n删除分区(对于内部表而言删除元数据，数据本身还在，外部表则不在）\nalter table tablename drop partiton (month=&#x27;202104&#x27;);\n\n添加列\nalter table table_name add columns (v1 int,v2 string);\n修改列名\nalter table test_change change v1 v1newname int;\n删除表\ndrop table tablename;\n清空表\ntruncate table tablename;\n\nps:只可以清空内部表\n\n\n数据查询SELECT 基本查询\n查询所有\nselect * from orderdb.orders;\n查询单列\nselect orderid,totalmoney,username,useraddres,paytime from orderdb.orders;\n\n查询数据量\nselect count(*) from orderdb.orders;\n\n过滤广东省订单\nselect * from orderdb.orders where useraddress like &#x27;%广东%&#x27;;\n\n找出广东省单笔营业额最大的订单\nselect * from orderdb.orders where useraddress like &#x27;%广东%&#x27; order by totalmoney desc limit 1;# desc 降序，limit 1 最大的一个\n\n分组、聚合\n统计未支付、已支付各自的人数\nselect ispay,count(*) as cnt from orderdb.orders group by ispay;\n\n在已付款订单中，统计每个用户最高的一笔消费金额\nselect userid,MAX(totalmoney) as max_money from orderdb.orders where ispay = 1 group by userid;\n\n统计每个用户的平均订单消费额\nselect userid,avg(totalmoney) as avg_money from orderdb.orders group by userid having avg_money &gt; 10000;# having 表示筛选，与where不同;where在分组前进行筛选的,而having是在分组后进行筛选\n\nJOIN\nJOIN 订单表和用户表，找出用户名\n# 内关联，目的是获取来自 orders 表的订单编号 (orderid)、用户ID (userid)，以及与之相关联的用户表中的用户名 (username)。select o.orderid,o.userid,u.username,o.totalmoney,o.useraddress,o.paytime from orderdb.orders o join orderdb.users u on o.userid = u.userid;\n左外关联，订单表和用户表，找出用户名\n左连接 (​*LEFT JOIN*​) 会返回左边表（​*orders*​）中所有的记录，同时匹配右边表（​*users*​）中相应条件的记录。如果右边表中没有匹配的记录，那么将会返回 ​​*NULL*​​ 值。\nselect o.orderid,o.userid,u.username,o.totalmoney,o.useraddres,o.paytime from orderdb.orders o left join orderdb.users u on o.userid = u.userid;\n\nRLIKErelike 关键字，可以供用户使用正则和数据进行匹配\n# 查找广东省的数据select * from orderdb.orders where useraddress rlike &#x27;.*广东.*&#x27;;# 查找用户地址是：xx省 xx市 xx区的数据select * from orderdb.orders where useraddress rlike &#x27;..省 ..市 ..区&#x27;;# 查找用户姓为张、王、邓select * from orderdb.orders where username rlike &#x27;[张王邓]\\\\S+&#x27;;# 查找手机号符合:188****0*** 规则select * from orderdb.orders where userphone rlike &#x27;188\\\\S&#123;4&#125;0\\\\S&#123;3&#125;&#x27;;\n\nUNION 联合用于将多个 select ​语句的结果组合成单个结果集。每个 select ​语句返回的列的数量和名称必须相同。否则将引发架构错误。\n基础语法:\n\nselect …\nunion [all]\nselect …\n\n# 联合两个查询结果集select * from course where t_id = &#x27;周杰伦&#x27;;\tunionselect * from course where t_id = &#x27;王力宏&#x27;;\n\nunion 默认有去重功能:\n# 直接联合两个同样的查询结果select * from courseunionselcet * from course;# 不需要去重效果selcet * from course\tunion allselect * from course;\n\n\n其他写法\n# union写在from中selcet t_id,count(*) from(\tselect t_id from myhive.course where t_id =&#x27;周杰伦&#x27;\t\tunion all\tselect t_id from myhive.course where t_id = &#x27;王力宏&#x27;) as u group by t_id;# 用于insert selcet中create table myhive.course2 like myhive.course;insert overwrite table myhive.course2\tselcet * from myhive.course\t\tunion all\tselcet * from myhive.course;\n\n抽样操作在大体量的数据环境下,对于表的一个简单 select * 都会非常慢，哪怕看很少的数据都会走 MapReduce 流程，Hive 提供的快速抽样的语法，可以快速从大表中随机抽取一些数据供用户查看\nTABLESAMPLE 函数\n语法 1，基于随机分桶抽样:\n​select ... from tb1 tablesample(bucket x out of y on (colname | rand())​\n\ny 表示将表数据随机划分成 y 粉(y 个桶）\nx 表示从 y 里面随机抽取 x 份数据作为取样\ncolname 表示随机的依据基于某个列的值\nrand()表示随机的依据基于整行\n\n示例:\n注意:\n1.使用 colname 作为随机依据，则其它条件不变下，每次抽样结果一致；\n2.使用 rand()作为随机依据，每次抽样结果都不同\nselect username,orderid,totalmoney from orderdb.orders tableample(bucket 1out of 10 on username);select * from orderdb.orders tableample(bucket 1 out of 10 on rand());\n\n语法 2，基于数据块抽样\n​select ... from tb1 tableample(num rows | num percent | num(K|M|G));​\n\nnum rows 表示抽样 num 条数据\nnum perfect 表示抽样 num 百分百比例的数据\nnum(K|M|G)表示抽取 num 大小的数据，单位可以是 K、M、G 表示 KB、MB、GB\n\n注意:\n使用这种语法抽样，条件不变的话，每一次抽样的结果都一致；即无法做到随机，只是按照数据顺序从前向后取。\n\n\nVirtual Columns 虚拟列虚拟列是 Hive 内置的可以在查询语句中使用的特殊标记，可以查询数据本身的详细参数。Hive 目前可用 3 个虚拟列:\n\nINPUT_FILE_NAME,显示数据行所在的具体文件\n\nBLOCK_OFFSET_INSIDE_FILE,显示数据行所在文件的偏移量\n\nROW_OFFSET_INSIDE_BLOCK,显示数据所在 HDFS 块的偏移量\n\n此虚拟列需要设置:SET hive.exec.rowoffset&#x3D;true 才可使用\n\n\n\n示例:\nselect orderId,userName,INPUT__FILE__NAME,BLOCK__OFFSET__INSIDE__FILE from orders;​\n​​\nHive 函数函数分类分为两大类:内置函数(Built-in Functions)、用户自定义函数 UDF（User-Defined Functions):\n​​\n官方文档\n\n查看函数列表\n使用 show function 查看当下可用的所有函数\n通过 describe function extended funcname 来查看函数的使用方式\n​​\n\nMathmatical Functions 部分数学函数\n\n–取整函数:round 返回 double 类型的整数值部分（四舍五入）\nselect round(3.1415926);\n–指定精度取证函数:round(double a,int d)返回指定精度 d 的 double 类型\nselect round(3.1415926,4);\n–取随机数:rand()每次执行都不一样，返回一个 0-1 范围内的随机数\nselect rand();\n–指定种子取随机函数:rand(int seed)得到一个稳定的随机序列\nselect rand(3);\n–求数字的绝对值\nselect abs(-3);\n–得到 pi 值(小数点后 15 位精度)\nselect pi();\n\n\nCollection Functions 集合函数\n\n\n\nReturn Type\nName(Signature)\nDescription\n\n\n\nint\nsize(Map&lt;K.V&gt;)\n返回 map 类型的元素个数\n\n\nint\nsize(Array)\n返回 array 类型的元素个数\n\n\narray\nmap_keys(Map&lt;K.V&gt;)\n返回 map 内的全部 key（得到的是 array）\n\n\narray\nmap_values(Map&lt;K.V&gt;)\n返回 map 内的全部 value（得到的是 array）\n\n\nboolean\narray_contains(Array, value)\n如果 array 包含指定 value，返回 True\n\n\narray\nsort_array(Array)\n根据数组元素的自然顺序按升序对输入数组进行排序并返回它\n\n\n\nType Conversion Functions 类型转换函数\n\n\n\nReturn Type\nName(Signature)\nDescription\n\n\n\nbinary\nbinary(string\nbinary)\n\n\nExpected “&#x3D;” to follow “type”\ncast(expr as )\n将表达式 expr 的结果转换为给定类型。例如，cast(‘1’ as BIGINT） 会将字符串 ‘1’ 转换为整数表示。如果转换不成功，则返回 null。对于 cast(expr as boolean)，对于非空字符串将会返回 True\n\n\n\nDate Functions 日期函数 - 部分\n\n\n\nReturn Type\nName(Signature)\nDescription\n\n\n\ntimestamp\ncurrent_timestamp()\n返回当前时间戳。在同一个查询中对 current _ time 戳的所有调用都返回相同的值。\n\n\ndate\ncurrent_date\n返回当前日期。在同一个查询中对 current_date 戳的所有调用都返回相同的值。\n\n\n2.1.0 版本之前返回 string 现在版本返回 date\nto_date(string timestamp)\n时间戳转日期\n\n\nint\nyear(string date)quarter(date&#x2F;timestamp&#x2F;string)month(string date)day(string date)dayofmonth(date)hour(string date)minute(string date)second(string date)weekofyear(string date)\n得到给定时间的：年得到给定时间的：季度得到给定时间的：月得到给定时间的：日得到给定时间的：当前月份第几天得到给定时间的：小时得到给定时间的：分钟得到给定时间的：秒得到给定时间的：本年第几周\n\n\nint\ndatediff(string enddate, string startdate)\n返回 enddate 到 startdate 之间的天数\n\n\n2.1.0 版本之前返回 string 现在版本返回 date\ndate_add(date&#x2F;timestamp&#x2F;string startdate, tinyint&#x2F;smallint&#x2F;int days)date_sub(date&#x2F;timestamp&#x2F;string startdate, tinyint&#x2F;smallint&#x2F;int days)\n日期相加: date_add(‘2008-12-31’, 1) &#x3D; ‘2009-01-01’.日期相减: date_sub(‘2008-12-31’, 1) &#x3D; ‘2008-12-30’.\n\n\n\nCondition Functions 条件函数\n\n\n\nReturn Type\nName(Signature)\nDescription\n\n\n\nT\nif(boolean testCondition, T valueTrue, T valueFalseOrNull)\n如果 testCondition 为 true，则返回 valueTrue，否则返回 valueFalseOrNull。\n\n\nboolean\nisnull( a )\n如果 a 为 NULL，则返回 true，否则返回 false。\n\n\nboolean\nisnotnull ( a )\n如果 a 不为 NULL，则返回 true，否则返回 false。\n\n\nT\nnvl(T value, T default_value)\n如果 value 为 null，则返回 default_value，否则 value。\n\n\nT\nCOALESCE(T v1, T v2, …)\n返回第一个不是 NULL 的 v，如果所有 v 都是 NULL，则返回 NULL。\n\n\nT\nCASE a WHEN b THEN c [WHEN d THEN e]* [ELSE f] END\n当 a &#x3D; b 时，返回 c;  [当 a &#x3D; d 时，返回 e]*  ;否则返回 f。\n\n\nT\nCASE WHEN a THEN b [WHEN c THEN d]* [ELSE e] END\nWhen a &#x3D; true, returns b; when c &#x3D; true, returns d; else returns e.a 可以是表达式，如 1&#x3D;1\n\n\nT\nnullif( a, b )\n如果 a&#x3D;b，则返回 NULL;否则返回 a 。等价：CASE WHEN a &#x3D; b then NULL else a\n\n\nvoid\nassert_true(boolean condition)\n如果 boolean_condition 结果不为 True，则引发异常报错比如：select assert_true (2&lt;1).\n\n\n\nString Functions 字符串函数\n\n\n\nReturn Type\nName(Signature)\nDescription\n\n\n\nstring\nconcat(string\nbinary A, string\n\n\nstring\nconcat_ws(string SEP, string A, string B…)\n同 concat，但是可以自己定义字符串之间的分隔符（SEP）\n\n\nint\nlength(string A)\n字符串长度\n\n\nstring\nlower(string A)upper(string a)\n全部转小写全部转大写\n\n\nstring\ntrim(string A)\n返回从 A 的两端裁剪空格得到的字符串。例如，trim(‘ foobar ’)的结果是‘ foobar’\n\n\narray\nsplit(string str, string pat)\n按照 pat 分隔字符串，pat 是正则表达式\n\n\n\nData Masking Functions 数据脱敏函数 -部分\n\n\n\nReturn Type\nName(Signature)\nDescription\n\n\n\nstring\nmask_hash(string|char|varchar str)\n对字符串进行 hash 加密非字符串加密会得到 NULL\n\n\n\nMisc. Functions 其他函数 -部分\n\n\n\nReturn Type\nName(Signature)\nDescription\n\n\n\nint\nhash(a1[, a2…]))\n返回参数的 hash 数字\n\n\nstring\ncurrent_user()\n返回当前登录用户\n\n\nstring\ncurrent_database()\n返回当前选择的数据库\n\n\nstring\nversion()\n返回当前 hive 版本\n\n\nstring\nmd5(string&#x2F;binary)\n返回给定参数的 md5 值\n\n\n\n\n案例基于 hadoop 和 hive 实现聊天数据系统分析，构建聊天数据分析表\n需求\n统计今日总消息量\n统计今日每小时消息量、发送和接收用户数\n统计今日各地区发送消息数据量\n统计今日发送消息和接收消息的用户数\n统计今日发送消息最多的 top10 用户\n统计今日接收消息最多的 Top10 用户\n统计发送人的手机型号分布情况\n统计发送人的设备操作系统分布情况\n\n数据内容\n大小:30w 条数据\n\n列分割符：hive 默认分隔符’\\001’\n\n数据字典及样例数据\n\n\n\n消息时间\n发件人昵称\n发件人账号\n发件人性别\n发件人 IP\n发件人系统\n发件人手机型号\n发件人网络制式\n发件人 GPS\n收件人昵称\n收件人 IP\n收件人账号\n收件人系统\n收件人手机型号\n收件人网络制式\n收件人 GPS\n收件人性别\n消息类型\n双方距离\n消息\n\n\n\n2021-11-0115:11:33\n古博易\n14747877194\n男\n48.147.134.255\nAndroid 8.0\n小米 Redmi K30\n4G\n94.704577,36.247553\n莱优\n97.61.25.52\n17832829395\nIOS 10.0\nApple iPhone 10\n4G\n84.034145,41.423804\n女\nTEXT\n77.82KM\n天涯海角惆怅渡，牛郎织女隔天河。佛祖座前长顿首，只求共度一百年。\n\n\n\n\n建库建表# 创建数据库create database db_msg;# 切换数据库use db_msg;# 列举数据库show databases;# 如果表存在就删除drop table if exists db_msg.tb_msg_source;# 建表create table db_msg.tb_msg_source(msg_time string comment &quot;消息发送时间&quot;,sender_name string comment &quot;发送人昵称&quot;,sender_account string comment &quot;发送人账号&quot;,sender_sex string comment &quot;发送人性别&quot;,sender_ip string comment &quot;发送人ip地址&quot;,sender_os string comment &quot;发送人操作系统&quot;,sender_phonetype string comment &quot;发送人手机型号&quot;,sender_network string comment &quot;发送人网络类型&quot;,sender_gps string comment &quot;发送人的GPS定位&quot;,receiver_name string comment &quot;接收人昵称&quot;,receiver_ip string comment &quot;接收人IP&quot;,receiver_account string comment &quot;接收人账号&quot;,receiver_os string comment &quot;接收人操作系统&quot;,receiver_phonetype string comment &quot;接收人手机型号&quot;,receiver_network string comment &quot;接收人网络类型&quot;,receiver_gps string comment &quot;接收人的GPS定位&quot;,receiver_sex string comment &quot;接收人性别&quot;,msg_type string comment &quot;消息类型&quot;,distance string comment &quot;双方距离&quot;,message string comment &quot;消息内容&quot;);\n\n加载数据先上传文件到 linux 系统，再通过 load 加载数据到表\nload data local inpath &#x27;/home/hadoop/chat_data-30w.csv&#x27; overwrite into table tb_msg_source;# 验证结果select msg_time,sender_name,sender_ip,sender_phonetype,receiver_name,receiver_network from tb_msg_source limit 10;\n\n\n数据清洗问题\n\n当数据中有一些数据的字段为空，不是合法数据\n\n\n\nselect msg_time,sender_name,sender_gps from db_msg.tb_msg_source where length(sender_gps) =0 limit 10;\n\n\n\n2.需求中，需要统计每天，每小时的消息量，但是数据中没有天和小时字段，只有整体时间字段，不好处理\n\nselect msg_time from db_msg.tb_msg_source limit 10;\n\n‍\n\n3.需求中，需要对经度和维度构建地区的可视化地图，但是数据中 GPS 经纬度为一个字段，不好处理\n\nselect sender_gps from db_msg.tb_msg_source limit 10;\n\n解决方法需求：\n\n需求 1 对字段为空的不合法数据进行过滤\n​where ​过滤 将为空的数据过滤掉\n​where length(sender_gps)&gt;0​\n\n需求 2 通过时间字段构建聊天和小时字段\n​date hour ​函数 分别取时间和小时\n​date(msg_time),hour(msg_time)​\n\n需求 3 从 GPS 的经纬度中提取经度和纬度\n​split ​函数 分割成数据再分别取前一二个\n​split(sender_gps,&#39;,&#39;)[0];​\n\n需求 4 将 ETL 以后的结果保存到一张新的 Hive 表中\n\n\n实现:\n# 创建一个新表create table db_msg.tb_msg_etl(msg_time string comment &quot;消息发送时间&quot;,sender_name string comment &quot;发送人昵称&quot;,sender_account string comment &quot;发送人账号&quot;,sender_sex string comment &quot;发送人性别&quot;,sender_ip string comment &quot;发送人ip地址&quot;,sender_os string comment &quot;发送人操作系统&quot;,sender_phonetype string comment &quot;发送人手机型号&quot;,sender_network string comment &quot;发送人网络类型&quot;,sender_gps string comment &quot;发送人的GPS定位&quot;,receiver_name string comment &quot;接收人昵称&quot;,receiver_ip string comment &quot;接收人IP&quot;,receiver_account string comment &quot;接收人账号&quot;,receiver_os string comment &quot;接收人操作系统&quot;,receiver_phonetype string comment &quot;接收人手机型号&quot;,receiver_network string comment &quot;接收人网络类型&quot;,receiver_gps string comment &quot;接收人的GPS定位&quot;,receiver_sex string comment &quot;接收人性别&quot;,msg_type string comment &quot;消息类型&quot;,distance string comment &quot;双方距离&quot;,message string comment &quot;消息内容&quot;,msg_day string comment &quot;消息日&quot;,msg_hour string comment &quot;消息小时&quot;,sender_lng double comment &quot;经度&quot;,sender_lat double comment &quot;纬度&quot;);# 使用insert 将改好的需求插入到新表中insert overwrite table db_msg.tb_msg_tb1select    *,date(msg_time) as msg_day,hour(msg_time) as msg_hour,    split(sender_gps,&#x27;,&#x27;)[0] as sender_lng,    split(sender_gps,&#x27;,&#x27;)[1] as sender_latfrom db_msg.tb_msg_sourcewhere length(sender_gps) &gt; 0;\n\n完成清洗的新表(部分):\n​\n\nETL 概念\n\nE,Extract,抽取\nT,Transform,转换\nL,Load,加载\n\n从 A 抽取数据(E)，进行数据转换过滤(T),将结果加载到 B(L),就是 ETL\n\n\n需求指标统计\n指标 1：统计今日消息总量\ncreate table db_msg.tb_rs_total_msg_cnt comment &#x27;每日消息总量&#x27; as select msg_day,count(*) as total_msg_cnt from db_msg.tb_msg_etl group by msg_day;\n\n‍\n​​\n‍\n‍\n\n统计每小时消息量、发送和接收用户数\ncreate table db_msg.tb_rs_hour_msg_cnt comment &#x27;每小时消息量趋势&#x27; as     select msg_hour,count(*) as total_msg_cnt,count(distinct sender_account) as sender_user_cnt,count(distinct receiver_account) as receiver_user_cntfrom db_msg.tb_msg_etl group by msg_hour;# as：这表示接下来的部分是一个 SQL 查询的结果将会被插入到新表中,count(*)：统计所有行的数量，即总消息数。# group by msg_hour：这是一个分组操作，它将查询结果按照 msg_hour 字段进行分组，意味着所有具有相同 msg_hour 值的行会被聚合在一起，从而得到每个小时的统计数据。\n\n​​\n‍\n\n需求 3：统计今日各地区发送消息总量\ncreate table db_msg.tb_rs_loc_cnt comment &#x27;每日各地区发送消息总量&#x27; as    select msg_day,sender_lng,sender_lat,count(*) as total_msg_cntfrom db_msg.tb_msg_etl group by msg_day, sender_lng, sender_lat;\n\n​​\n\n需求 4：统计今日发送和接收用户人数\ncreate table db_msg.tb_rs_user_cnt comment &#x27;今日发送和接收用户人数&#x27; as    select msg_day,count(distinct sender_account) as sender_user_cnt,count(distinct receiver_account) as receiver_user_cnt           from db_msg.tb_msg_etl group by msg_day;# 这里注意要加distinct关键字，进行去重，每个人每天能发送多条消息\n\n​​\n\n需求 5：统计发送消息条数最多的 Top10 用户\ncreate table db_msg.tb_rs_s_user_top10 comment &#x27;发送消息条数最多的top10用户&#x27; as     select sender_name,count(*) as sender_msg_cntfrom db_msg.tb_msg_etl group by sender_name order by sender_msg_cnt desc limit 10;# desc 表示降序排序，意味着数值越大的将会排在前面\n\n​​\n\n需求 6：统计接收消息最多的 top10 用户\ncreate table db_msg.tb_rs_r_user_top10 comment &#x27;接收消息条数最多的top10用户&#x27; as    select receiver_name,count(*) as receiver_msg_cntfrom db_msg.tb_msg_etl group by receiver_name order by receiver_msg_cnt desc limit 10;\n\n​​\n\n需求 7：统计发送人的手机型号分布\ncreate table db_msg.tb_rs_sender_phone comment &#x27;统计发送人的手机型号分布&#x27; as    select sender_phonetype,count(*) as cnt from db_msg.tb_msg_etl group by sender_phonetype;\n\n​​\n\n需求 8：统计发送人的手机 os 分布\ncreate table db_msg.tb_rs_sender_phone comment &#x27;统计发送人的手机型号分布&#x27; as    select sender_phonetype,count(*) as cnt from db_msg.tb_msg_etl group by sender_phonetype;\n​​\n\n\n","categories":["BigData"],"tags":["hadoop","hive","hdfs"]},{"title":"力扣<py>","url":"/2023/06/04/%E5%8A%9B%E6%89%A3-py/","content":"977.有序数的平方\n使用python推导式+内置sort函数表达式:[表达式 for 变量 in 列表] or [表达式 for 变量 in 列表 条件] 使用推导式计算平方后的数据，再调用sort()方法完成排序\n class Solution:    def sortedSquares(self, nums: List[int]) -&gt; List[int]:        res=[num**2 for num in nums]        res.sort()        return res\n\n采用快排超出时间限制  \n  class Solution:def Partion(self,res,low,high):    i=(low - 1)    pivot=res[high]    for j in range(low,high):        if res[j]&lt;=pivot:            i=i+1            res[i],res[j]=res[j],res[i] # 小于pivot的往后移动    res[i+1],res[high]=res[high],res[i+1] #把pivot放入合适位置    return (i+1)def Qsort(self,res,low,high):    if low &lt;high :        pi = self.Partion(res,low,high)        self.Qsort(res,low,pi-1)        self.Qsort(res,pi+1,high)def sortedSquares(self, nums: List[int]) -&gt; List[int]:    res=[num**2 for num in nums]    self.Qsort(res,0,len(nums)-1)    return res\n\n双指针 采用双指针，left和right。先建立一个新的数组其值是nums数组平方后的，然后left指向第一个，right指向最后一个，在定义s为新指针，从当left&lt;&#x3D;right时，双向遍历，并将其值大的一个放入原数组nums的最后，当一次遍历完时，nums数组也完成了从小到大的排序。\nclass Solution: def sortedSquares(self, nums: List[int]) -&gt; List[int]:     res=[num**2 for num in nums]     left=0     right=len(nums)-1     s=right #s是新指针，从后往前排     # 大的往后排     while left&lt;=right:         if res[left]&lt;=res[right]:             nums[s]=res[right]             s-=1             right-=1         else:             nums[s]=res[left]             s-=1             left+=1     return nums\n\n27.移除元素\n一次遍历把不等于val的值放入数组中\nclass Solution: def removeElement(self, nums: List[int], val: int) -&gt; int:     if (nums == None and len(nums)==0):         return 0     s=0 # s的值代表数组的下标     for f in range(0,len(nums)):         if (nums[f]!=val):             nums[s]=nums[f]             s+=1     return s\n\n59.螺旋矩阵||\n采用四个循环每次循环解决一个方向 初始化数组后先从左边开始解决，矩阵是n*n的大小，将矩阵第一个默认设置为1，设置一个变量cnt&#x3D;2，从第二个开始依次填充，当下一位位置未被填充时填充cnt，当左边达到边界并且下一个是未被填充时，开始像下填充，同理，当向下填充达到边界且下一个未被填充后向左，再向上，当cnt&#x3D;&#x3D;n^2时完成螺旋矩阵\n class Solution:def generateMatrix(self, n: int) -&gt; List[List[int]]:    nums = [[0] * n for _ in range(n)] # 初始化数组 n行n列    i=0    j=0    cnt = 2    nums[0][0]=1    while cnt &lt;= n*n:        # left        while j&lt;n-1 and nums[i][j+1]==0:            j +=1            nums[i][j]=cnt            cnt +=1        # down        while i&lt;n-1 and nums[i+1][j]==0:            i+=1            nums[i][j]=cnt            cnt+=1        # left        while j&gt;0 and nums[i][j-1]==0:            j-=1            nums[i][j]=cnt            cnt +=1        # up        while i&gt;0 and nums[i-1][j]==0:            i-=1            nums[i][j]=cnt            cnt +=1    return nums\n\n1.两数之和\n双重循环利用两个for循环完成查找\n class Solution:def twoSum(self, nums: List[int], target: int) -&gt; List[int]:    ans=[0] *2     for i in range(len(nums)):        for j in range(i + 1, len(nums)):            # 如果两个数相加等于target记录其下标             if nums[i] + nums[j] == target:                ans[0] = i                ans[1] = j    return ans\n\n字典+枚举 从评论区看到的方法，利用字典的键值配对，和target0-val来找另一个val的方式，很巧妙 字典+枚举的方式可以优化算法使得时间复杂度＜o(n^2) 先使用dict()函数创建一个空的records字典，然后再用enumerate()函数将nums变成枚举类型，遍历nums，判断target - val是否在字典records里面(若数组中有两个数val加起来等于target，那么target-val的值也一定在数组中)，若不在则将val和其下标index记录字典，若在字典中则返回target-val值的下标和val的下标，即为所求，代码如下：\n class Solution:def twoSum(self, nums: List[int], target: int) -&gt; List[int]:    records=dict()    for index,val in enumerate(nums):        if target - val not in records:            records[val]=index # 记录当前val的索引值到字典中        else:             return [records[target-val],index]\n\n重新排序+双指针 利用sorted()函数将数组重新排序，注意:不能直接排序nums数组，这这样会改变其原有的索引值，可以用下面两种方法来排序:1.利用numerate()函数将nums转换成元组，按照值来排序，这样不会改变其原有元素的索引值。2.直接排序原数组的下标，将待排序的数组利用range(len(nums))生产一个0~len(nums)-1的序列，按照nums数组的值来进行排序，这样就能得到一个按照值来排序的索引数组。排好序后，利用双指针head和tail一个从前往后一个从后往前，依次遍历判断和与target的关系，两种方式的代码如下: 第一种：\n class Solution:def twoSum(self, nums: List[int], target: int) -&gt; List[int]:    sorted_list = sorted(enumerate(nums),key=lambda x: x[1]) # 排好序的元组    head = 0    tail = len(nums) - 1    res = sorted_list[head][1] + sorted_list[tail][1] #用来判断与target的关系    while res != target:        if res &gt; target: # 和比target大说明tail的值大了，tail向前移动            tail -= 1        if res &lt; target: # 和比target小说明head的值小了，head向后移动            head += 1        res = sorted_list[head][1] + sorted_list[tail][1] # 每次移动完成后更新res    return [sorted_list[head][0], sorted_list[tail][0]]\n\n 第二种:\n class Solution:def twoSum(self, nums: List[int], target: int) -&gt; List[int]:    sorted_index=sorted(range(len(nums)),key = lambda x:nums[x]) # 排序nums，返回的索引序列    head = 0    tail = len(nums) - 1    res = nums[sorted_index[head]] + nums[sorted_index[tail]] # sorted_index[head]其值对于nums索引位置    while res != target:        if res &gt; target:            tail  -= 1        if res &lt; target:            head += 1        res = nums[sorted_index[head]] + nums[sorted_index[tail]]    return [sorted_index[head],sorted_index[tail]]\n\n34.在排序数组中寻找元素的第一个和最后一个位置\n类二分查找类似于二分查找，找到第一个等于target的位置，记录后，再继续找到大于target的第一个位置记录，则这区间为所求，关键在于:边界控制条件。由于边界控制不好，导致代码无法运行，看了评论区代码后，依照写了两个函数searchleft和searchright分别查找左边界和有边界；后面看到另一位大神的代码后，发现可以更加简洁，只需一个函数searchleft找到左边界后，右边界依旧使用searchleft，查找值为target+1找到后再将结果-1这样就找到了target的右边界，非常巧妙！\n class Solution:def searchRange(self, nums: List[int], target: int) -&gt; List[int]:    # 找到左边界    def SearchLeft(nums,target):        low=0        high=len(nums)-1        while low&lt;=high:            mid = (low+high)//2            # 判断条件必须加等号，防止漏掉元素            if nums[mid]&gt;=target:                high=mid-1            else:                low=mid+1        return low    # 找右边界    # def SearchRight(nums,target):    #     low=0    #     high=len(nums)-1    #     while low&lt;=high:    #         mid = (low+high)//2    #         if nums[mid]&gt;target:    #             high=mid-1    #         else:    #             low=mid+1    #     return high    # leftindex=SearchLeft(nums,target)    # rightindex=SearchRight(nums,target)    # searchleft找到的是第一个&gt;target+1的数，数组是有序的；-1后即为target的右边界值    leftindex=SearchLeft(nums,target)    rightindex = SearchLeft(nums,target+1)-1    if leftindex&lt;=rightindex:        return [leftindex,rightindex]    else:        return [-1,-1]\n\n242.有效字母的异位词\n用数组记录出现字符串的个数，在比较数组定义一个数组arr初始化为0.用来记录s中字符出现的个数，利用ord()函数，将s中每个字符转换为Unicode值，再在数组相应位置+1操作，遍历s，这样就记录了s中所有字符出现的个数。同样再遍历t，不过这次数组再相应位置进行-1操作，如果两个字符串所含字符个数是相等的，那么arr数组应该为0，若不为0则不等，代码:\nclass Solution: def isAnagram(self, s: str, t: str) -&gt; bool:     # 判断s 和 t 的长度是否相等     if (len(s)==len(t)):         arr = [0] * 26 # 初始化数组用来记录 s 中出现字符的个数         for i in s:             arr[ord(i)-ord(&#x27;a&#x27;)]+=1         for j in t:             arr[ord(j)-ord(&#x27;a&#x27;)]-=1 # 若出现相同的字符贼减一         # 判断arr数组是否为空         for i in range(26):             if arr[i]!=0:                 return False         return True     else:         return False\n\ndefaultdictdefaultdict是python中的一个内置字典子类，重载了一个方法来实现默认值的设定。在创建defaultdict对象，需要提供一个参数作为默认值或者一个函数用来生成默认值。\nclass Solution:def isAnagram(self, s: str, t: str) -&gt; bool:    from collections import defaultdict    sdict=defaultdict(int)    tdict=defaultdict(int)    for i in s:        sdict[i]+=1    for j in t:        tdict[j]+=1    if sdict==tdict:        return True    else:        return False\n\n202.快乐数\n转为字符串计算平方，然后判断是否循环我一开始是想先把给的数字每次队10取余然后平方加起来，后面发现python可以更简单的实现这一步，就是把给的n转化为字符串然后遍历字符串将每次遍历的字符转换为int在平方相加，然后再定义一个列表，大小为n，将每次替换后的结果存入这个列表中，若此后的遍历出现了和列表中一样的数，那么这个数就不是快乐数，若循坏到1则为快乐数，代码如下:\n class Solution:    def Caculate_Pow(self,num:int) -&gt; int:        n = 0 #用来返回的值        # 将n变为字符串遍历再变为int求平方和        for i in str(num):            n += int(i)**2        return n    def isHappy(self,n:int) -&gt; bool:        ret = [n] #设置一个n大小的列表用来判断是否出现了循环        while n!=1:            n=Caculate_Pow(n)            if n in ret:                return False            else:                ret.append(n) # 若未出现再ret中且不等于1时，将其加入到ret中        return True\n\n454. 四数相加 II\n哈希表+分治这题没思路，做不出，听了老师的讲解，由题所给条件nums1[i] + nums2[j] + nums3[k] + nums4[l] &#x3D;&#x3D; 0 –&gt; nums1[i] + nums2[j] &#x3D; - nums3[k] - nums4[j] 所以我们可以分别处理nums1 2 和nums3 4 并且定义两个字典dic_A 和 dic_B 分别记录两个数组组合的值和次数。再判断dic_A和中与dic_B相同的值，并且将两者出现的次数相乘，因为是组合问题所以应该是相乘而不是相加代码示例如下:\nclass Solution:def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -&gt; int:    dic_A = &#123;&#125;    dic_B = &#123;&#125;    res = 0    # 先求两个的交集    #nums1[i] + nums2[j]  == - nums3[k] - nums4[l]    for i in nums1:        for j in nums2:            sum_ij = i + j            dic_A[sum_ij] = dic_A.get(sum_ij,0) + 1 # 记录sum_ij出现的次数        for k in nums3:        for l in nums4:            sum_kl = -k-l            dic_B[sum_kl] = dic_B.get(sum_kl,0) + 1        # 如果dic_A和dic_B有交集，他们次数乘积累加后为所求，注意这是组合问题，不能相加    for item in dic_A.items():        if item[0] in dic_B:            res += item[1] * dic_B[item[0]]    return res\n\n344. 反转字符串\n双指针原地逆转设置双指针i,j一个指向头部，一个指向尾部，再用tmp当中间变量交换，当i&gt;&#x3D;j时完成交换。\nclass Solution:def reverseString(self, s: List[str]) -&gt; None:    &quot;&quot;&quot;    Do not return anything, modify s in-place instead.    &quot;&quot;&quot;    i = 0    j = len(s) - 1    while i&lt;=j:        tmp = s[j]        s[j] = s[i]        s[i] = tmp        i += 1        j -= 1\n\n876. 链表的中间结点\n快慢指针设置快慢指针，慢的为slow，快的为fast，慢的一次走一步，快的一次走两步，当fast走到末尾时，slow处于中间位置\n# Definition for singly-linked list.# class ListNode:#     def __init__(self, val=0, next=None):#         self.val = val#         self.next = nextclass Solution:    def middleNode(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        if head == None:            return None        slow = head        fast = head        while fast and fast.next:            slow = slow.next            fast = fast.next.next        return slow\n\n206.反转链表\n双指针+临时变量记录我这里是重新返回了一个新的链表，按照头插法遍历原链表，就完成了链表的反转\n# Definition for singly-linked list.# class ListNode:#     def __init__(self, val=0, next=None):#         self.val = val#         self.next = nextclass Solution:    def reverseList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        # 链表为空直接返回        if head == None:            return head        # i指针遍历head链表        i = head        NewNode = None        # j指针指向新的链表        j = NewNode        # 头插法实现逆转        while i!= None:            tmp = i.next            i.next = j            j = i            i = tmp        return j        \n\n160. 相交链表\n先判断长度，然后从位置相同的结点同时遍历，找相同的结点先计算后两个链表的长度，然后利用一个变量计算差值，让长的那个链表与短的那个链表同时向后遍历，找到相同的结点\n# Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    # 计算链表的长度    def get_length(self,head:ListNode) -&gt; int:        count = 0        i = head        while i:            count += 1            i = i.next        return count    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; Optional[ListNode]:        m = self.get_length(headA)        n = self.get_length(headB)        node_headA = headA        node_headB = headB        判断哪个链表长，记录差值，然后让长的链表先走，保证两个链表能在同一个位置向后遍历        if m &gt; n:            cha = m - n            i_headA = 0            while i_headA &lt; cha:                node_headA=node_headA.next                i_headA += 1        else:            cha = n - m            i_headB = 0            while i_headB &lt; cha:                node_headB=node_headB.next                i_headB += 1        # 如果遍历到相同的结点返回        while node_headA and node_headB:            if node_headA == node_headB:                return node_headA            node_headA = node_headA.next            node_headB = node_headB.next        return None\n\n20.有效的括号一开始我是想记录每个字符出现的次数然后判断是否为奇数，当然通过不来，因为没要考虑到顺序问题，”([)]”这个测试用例就会失败\n\n使用replace()替换字符设置判断条件，遇到’{}’,’[]’,’()’,直接替换为空字符\nclass Solution:def isValid(self, s: str) -&gt; bool:    while &#x27;&#123;&#125;&#x27; in s or &#x27;()&#x27; in s or &#x27;[]&#x27; in s:        s=s.replace(&#x27;&#123;&#125;&#x27;,&#x27;&#x27;)        s=s.replace(&#x27;[]&#x27;,&#x27;&#x27;)        s=s.replace(&#x27;()&#x27;,&#x27;&#x27;)    return s==&#x27;&#x27;\n\n哈希+栈K神解答;先创建一个包含所需字符的字典dic，然后再定义一个stack数组用来模拟栈操作，遍历s看字符是否存在于dic中，若存在入栈(查找左括号的过程),当遍历到不是左括号的时候出栈，看出栈的元素与当前元素是否匹配，若不匹配直接返回False，需要注意的是，stack初始时应该添加一个变量进去，同理在dic中添加一个不属于s的字符，最后判断stack长度为1时，返回True\n class Solution:def isValid(self, s: str) -&gt; bool:    dic = &#123;&#x27;[&#x27;:&#x27;]&#x27;,&#x27;(&#x27;:&#x27;)&#x27;,&#x27;&#123;&#x27;:&#x27;&#125;&#x27;,&#x27;a&#x27;:&#x27;a&#x27;&#125;    stack = [&#x27;a&#x27;]    for i in s:        if i in dic:            stack.append(i)        elif dic[stack.pop()] != i:            return False    return len(stack) == 1\n\n496. 下一个更大元素 I\n由题可知nums2包含了nums1，因此可以用index查找nums1中数在nums2中的下标，然后再判断从该处起是否有大于nums1的数，若有则赋值到nums1的相应位置，若没有则将nums1相应位置设置为-1\nclass Solution:def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:    for i in range(len(nums1)):        index = nums2.index(nums1[i]) + 1 # 查找nums1中的值再nums2中的位置，加一代表下一位        flag = 0 # flag用来判断nums2中是否有符合条件的数        while index &lt; len(nums2):            if nums2[index] &gt; nums1[i]: # nums2的右边有大于nums1的数                nums1[i] = nums2[index] # 将第一个大于的数赋值到nums1相应的位置                flag = 1                break            index += 1        if flag == 0:            nums1[i] = -1    return nums1\n\n字典+双循环(同学解答) 其实这种方式和我自己用index方式找下标本质上是一样的，不过这是用到了双循环，从nums2中去找第一个大于nums当前位置上的数。具体实现是:\n\n\n\n1.先初始化结果数组为-1 长度为nums1的长度 2.然后将nums2中的数字和下标存入到字典当中 3.遍历nums1，同时遍历nums2从nums1当前值在nums2中的下标开始往后找，若找到一个比nums1此时位置上的数大的数后将其赋值到结果数组\n\n\n\n class Solution:def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:    ans = [-1] * len(nums1)    dic = &#123;&#125;    # 将nums2的数字和下标存入字典    for item in range(len(nums2)):        dic[nums2[item]] = item    # 遍历nums1 在nnums2中从nums1当前数字的下标往后找若有大于nums1的就赋值放入ans中    for i in range(len(nums1)):        for j in range(dic[nums1[i]],len(nums2)):            if nums2[j] &gt; nums1[i]:                ans[i] = nums2[j]                break # 找到一个就结束当前循环    return ans\n\n字典+栈(同学解答) 这个方法采用的是将nums2中存在后一个数大于前一个数的存入到字典中，key为待查找数，value为向后第一个大于key的数。当遍历完nums2后，从nums1开始遍历，并查找dic中是否存在该数，存在将其放到待放回数组中，具体代码实现:\n class Solution:def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:    stack = []    dic = &#123;&#125;    res = []    for i in range(len(nums2)):        # 当栈不为空，并且nums2[i]大于栈顶元素时，更新字典        while stack and stack[-1]&lt;nums2[i]:            dic[stack.pop()] = nums2[i]        stack.append(nums2[i]) # 更新栈顶、    # 在nums2中查找nums1    for i in nums1:        res.append(dic.get(i,-1))    return res\n\n150. 逆波兰表达式求值\n使用栈来计算定义一个栈，设置条件判断，是运算符号就出栈，计算后后再入栈，这里注意的是在计算正数与负数相除时，要使用int进行取整，不能用 &#x2F;&#x2F; 进行整除。再进行减法和除法运算时要先用一个临时变量记录出栈的数据，再用用出栈的数减去或者除以这个临时变量，遍历tokens计算得到最后的结果\nclass Solution:def evalRPN(self, tokens: List[str]) -&gt; int:    if len(tokens) == 1:        return int(tokens[0])    stack = []    res = 0    for i in tokens:        if i != &#x27;+&#x27; and i != &#x27;-&#x27; and i != &#x27;/&#x27; and i != &#x27;*&#x27;:            stack.append(int(i))        elif i == &#x27;+&#x27;:            res = stack.pop() + stack.pop()            stack.append(res)        elif i == &#x27;-&#x27;:            temp = stack.pop() # 减数            res = stack.pop() - temp            stack.append(res)        elif i == &#x27;*&#x27;:            res = stack.pop() * stack.pop()            stack.append(res)        elif i == &#x27;/&#x27;:            tmp = stack.pop() # 除数            res = int(stack.pop()/tmp)            stack.append(res)    return res\n\nLC官方解答(栈)\nclass Solution:    def evalRPN(self, tokens: List[str]) -&gt; int:        op_to_binary_fn = &#123;            &quot;+&quot;:add,            &quot;-&quot;:sub,            &quot;*&quot;:mul,            &quot;/&quot;:lambda x,y:int(x/y),        &#125;        stack = list() # 定义栈        for token in tokens:            try:                num = int(token) # 不是操作符            except ValueError: # 遇到操作符执行相应的操作                num2 = stack.pop()                num1 = stack.pop()                num = op_to_binary_fn[token](num1,num2) # 注意num1和mum2的位置，先出栈的作为除数            finally:                stack.append(num)        return stack[0] # 最后的运算结果\n\n347. 前 K 个高频元素\n排序+字典先将原数组排好序，再统计每个数字出现的次并将其存入到字典dict_nums中，再将dict_nums按照出现的次数来进行排序，最后将前k个赋值到list_r中即可\n\n\n\n代码如下\n\n\n\nclass Solution:def topKFrequent(self, nums: List[int], k: int) -&gt; List[int]:    # 用来返回结果的列表    list_r = []    # 存放每个数字及出现的次数    dict_nums = &#123;&#125;    # 记录每个数字出现的次数    cnt = 0    # 先排序    nums = sorted(nums)    # 将每个数字出现的次数记录到dict_nums    tmp = nums[0]    i = 0    while i &lt; len(nums):        if nums[i] == tmp:            cnt += 1        if nums[i] != tmp:            dict_nums[nums[i - 1]] = cnt            cnt = 1            tmp = nums[i]        i += 1    i = 0    # 记录最后一个数字的出现次数    dict_nums[nums[len(nums) - 1]] = cnt    # 如果原数组不止一个数的话，按照值的大小来排序字典    if len(dict_nums) &gt; 1:        new_dict = sorted(dict_nums.items(), key=lambda x: x[1],reverse=True)        new_dict = dict(new_dict)    else:        new_dict = dict_nums    # 将原数组中出现次数前k的赋值到list_r    for key, val in new_dict.items():        if i &lt; k:            list_r.append(int(key))            i += 1    return list_r\n\n\n\n\n简洁版代码\n\n\n\nclass Solution: def topKFrequent(self, nums: List[int], k: int) -&gt; List[int]:     dic = &#123;&#125;     for i in nums:         dic[i] = dic.get(i,0) + 1     return([i for i,j in sorted(dic.items(),key=lambda x:x[1],reverse=True)][0:k])\n\n字典+堆先用字典记录每个数字及其出现次数，在将其出现次数都*-1，然后根据次数来建立小根堆，遍历小根堆，则为前k个高频元素\n\n\n\n代码如下\n\n\n\nclass Solution:def topKFrequent(self, nums: List[int], k: int) -&gt; List[int]:    dic = &#123;&#125;    res = [] # 用来返回结果    heap = [] # 建立小根堆    # 记录每个数字及其出现次数    for i in nums:        dic[i] = dic.get(i,0) + 1    # 将其转换成列表，并且将键值反转，并且-1*出现次数，以便后面建立小根堆    ls = [(-1 * value,key) for key,value in dic.items()]    # 建立小根堆    heapq.heapify(ls)    for i in range(k):        res.append(heapq.heappop(ls)[1])    return res\n\n278. 第一个错误的版本\n二分查找如果直接用for循环进行遍历的话，会超出时间复杂度，所以这里可以选择采用二分查找的方式，时间复杂度为O(log n),不过针对这个题目，不能直接套用二分查找，应作相应的改变，最后返回的值不是mid而是first，因为可能不止一个错误的版本，而题目要求返回第一个错误的版本，所以当isBadVersion(mid)为True时last = mid - 1查找左半部分是否还存在错误版本，反之则first = mid + 1,当first&gt;last时，first的位置就为第一个错误版本\n# The isBadVersion API is already defined for you.# def isBadVersion(version: int) -&gt; bool:class Solution:    def firstBadVersion(self, n: int) -&gt; int:        first = 1        last = n        while first &lt;= last:            mid = (first + last) // 2            if isBadVersion(mid):                last = mid -1 # 查找左半部分是否还存在错误版本            else:                first = mid + 1        return first # 当first&gt;last时first所在位置就是首个错误版本\n\n704. 二分查找\n二分查找非常典型的二分查找题目，直接使用二分查找的相关代码即可\nclass Solution: def search(self, nums: List[int], target: int) -&gt; int:     low = 0     high = len(nums) - 1     while low &lt;= high:         mid = (low + high) // 2         if nums[mid] == target:             return mid         elif nums[mid] &gt; target:             high = mid -1         else:             low = mid + 1     # 不存在返回-1     return -1\n\n240.搜索二维矩阵 II\n暴力二分法整个二维矩阵又可以看成是m个含有n个元素的一维数组组成，因此可以遍历真个m个数组，在遍历每一个数组的时候采用二分查找减少时间消耗，这样的时间复杂度为mlogn\nclass Solution:# 二分查找def func(self,nums,target):    low = 0 # 首    high = len(nums) - 1 # 尾    while low &lt;= high:        mid = (low + high ) // 2        if nums[mid] == target:            return True        elif nums[mid] &gt; target:            high = mid - 1        else:            low = mid + 1    return Falsedef searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool:    m = len(matrix) # 行数，表示又多少个一维数组    n = len(matrix[0]) # 列数，表示每个一维数组中所含元素的个数    # 遍历每个一个一维数组使用二分查找去查找    for i in range(m):        if self.func(matrix[i],target):            return True    return False\n\n分治法整个二维数组左下角的第一个数是第一列的最大数，是最后一行的最小数；因此可以从左下角开始向上，右遍历；从右上角也是一样的，但是不能从另外两个角去遍历，因为数组的增大方向是从上到小，从左到右，不管先遍历哪个方向，当遇到大于或者小于target时，另一个方向去遍历时，下一个数依旧是大于或者小于target，因为在增大方向上下一个数必定是比前一个数大的，因此可以选择从左下角或者右上角遍历；这里拿左下角举例:如果左下角第一个数大于target那么就像上遍历，当上方向上的数小于target时，就想右遍历，若右方向的数大于target的话，再在此基础上向上遍历，直至找到target，若不存在target则直接返回False时间复杂度O(m+n)\nclass Solution:def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool:    m = len(matrix) # 行    n = len(matrix[0]) # 列    # 行列为空的话直接返回false    if m == 0:        return False    if n == 0:        return False    # i 代表上下方向，j代表左右方向    i = m - 1     j = 0    while i&gt;=0 and j &lt; n:        if matrix[i][j] == target:            return True        # 小于target时向右移动，否则向上移动        elif matrix[i][j] &lt; target:            j = j + 1       else:            i = i - 1    return False\n\n275. H 指数 II\n二分法，关键是返回的区间理解好题目后才好下手,要理解h 指数是指他（她）的 （n 篇论文中）总共有 h 篇论文分别被引用了至少 h 次；题目的意思是返回满足条件的个数不是刚好满足条件的那个个论文引用次数，是所有大于这个条件的个数，比如[1,2]那么返回的就是1，引用次数大于2的为0，大于1的为1，又比如[0,1,3,5,6,8,9]返回的就是4，表示至少有四篇论文引用次数大于4其余的论文引用次数小于4。所以就可以用二分法的变式来解决该问题，时间复杂度为logn\nclass Solution:    def hIndex(self, citations: List[int]) -&gt; int:        low = 0        high = len(citations) - 1        while low &lt;= high:            mid = (low + high) // 2            # 判断当前论文引用次数是否大于当前引用次数论文的个数            if citations[mid] &gt;= len(citations) - mid:                high = mid - 1            else:                low =  mid + 1        # 当循环结束时low位置所指向的值的下一个就是第一个满足的值，因此用数组长度-当前low值就是所有满足的个数        return len(citations) - low\n\n逆转数组后一次遍历逆转数组后通过比较元素的索引和值来确定h值，逆转数组为了方便计算，i+1是因为要比较引用次数而索引下标是从0开始所以用i+1,然后从头开始遍历\nclass Solution:    def hIndex(self, citations: List[int]) -&gt; int:        # 反转        citations = citations[::-1]        length = len(citations)        index = 0        for i in range(length):            if citations[i] &gt;= i+1:                index = i+1        return index\n\n81. 搜索旋转排序数组 II\n直接遍历数组找target时间复杂度O(n),用for循环遍历数组看target是否在其中\n   class Solution:    def search(self, nums: List[int], target: int) -&gt; bool:        for i in range(len(nums)):            if nums[i] == target:                return True        return False   ```  2. 二分查找(官方解答)   由于数组中元素是可以有重复的，因此可能会出现`nums[left]=nums[mid]=nums[right]`的情况，对于这种情况，对区间的左边界减一，右边界加一来进行新的二分查找   ```python    class Solution:    def search(self,nums,target):        # 数组为空时，直接返回False        if len(nums)==0:            return False        # 数组进一个元素时，直接判断        if len(nums)==1:            return True if nums[0]==target else False        left,right=0,len(nums)-1        while left&lt;=right:            mid=(left+right)//2            if nums[mid]==target:                return True            # 划分数组,并判断            # 左边界的值=中间位置值=右边界的值时，构建新数组            if nums[left]==nums[mid]==nums[right]:                left+=1                right-=1            elif nums[left]&lt;=nums[mid]:                # 左边的数组是有序数组，且target存在于区间内，则移动右指针；否则，移动左指针                if nums[left]&lt;=target&lt;=nums[mid]:                    right=mid-1                else:                    left=mid+1            else:                # 右边的数组是有序数组，且target存在于区间内，则移动左指针；否则，移动否指针                if nums[mid]&lt;target&lt;=nums[len(nums)-1]:                    left=mid+1                else:                    right=mid-1        return False\n\n53. 最大子数组和\n贪心算法刚开始我是用的双循环去统计最大和，但是会超出时间复杂度，贪心算法的思想是:在每一步选择中都采用当前状态下最优的选择，而不考虑之后的结果,定义一个sum用来记录当前值与当前值和下一个数相加的大小，返回值大的那个给sum,这个sum就是前几项的和最大值，然后再将sum与待返回的数res做比较将值的那个赋值给res。\nclass Solution:     def maxSubArray(self, nums: List[int]) -&gt; int:         if not nums:             return NULL         res = sum = nums[0]         for i in range(1,len(nums)):             sum = max(nums[i],sum+nums[i]) # 更新前i个数中的最大和             res = max(sum,res) # 更新最大和         return res\n\n动态规划动态规划是一种解决复杂问题的算法思想，通常用于解决具有重叠子问题和最优子结构的问题。基本思想是将问题分解为更小的子问题，通过解决子问题来解决原始问题；将原数组在遍历时如果前一个数大于0则加到这个数上小于0则不变，最后遍历数组找出最大那个即可\n class Solution:    def maxSubArray(self, nums: List[int]) -&gt; int:        n = len(nums)        for i in range(1,n):            if nums[i-1] &gt; 0:                nums[i] += nums[i-1]        return max(nums)\n\n1480. 一维数组的动态和\n后一个加上前一个的累加，动态规划\nclass Solution: def runningSum(self, nums: List[int]) -&gt; List[int]:     for i in range(1,len(nums)):         nums[i] = nums[i] + nums[i-1]     return nums\n\n1991. 找到数组的中间位置\n动态规划用right_sum记录数组的和，然后再遍历数组，遍历一个减去一个，用left_sum记录遍历数组的和，当左等于右时，即为中间位置\nclass Solution: def findMiddleIndex(self, nums: List[int]) -&gt; int:     if len(nums) == 1:         return 0     left_sum,right_sum = 0,sum(nums)     for i in range(len(nums)):         right_sum -= nums[i]         if left_sum == right_sum:             return i         left_sum += nums[i]     return -1\n\n560. 和为 K 的子数组\n使用字典(看评论区大神解决思想)可以使用一个字典dic来记录数组的前缀和的个数,用变量sums记录前i个数的前缀和,存入字典当中,再定义变量res用来返回和为k的连续子数组个数，注意的是dic字典需要初始为&#123;0:1&#125;,代表连续子数组本身，代码如下:\nclass Solution: def subarraySum(self,nums:List[int],k:int) -&gt; int:     res = sums = 0     dic = &#123;0:1&#125;     for i in range(len(nums)):         sums += nums[i]         res += dic.get(sums - k,0) # sums - k 表示前i项和减去k的结果若存在再dic中，则说明前i项和中包含和为k的连续子数组，个数为sums - k 的值再dic中的次数         dic[sums] = dic.get(sums,0) + 1 # 记录每个前缀和出现的次数     return res\n\n739. 每日温度\n双循环暴力解(超出时间限制)使用两个for循环暴力求解，时间复杂度为O(n^2),核心思想就是在第二个for循环中去找下一个比当前值大的那个，使其下标相减即为相差的天数\nclass Solution: def dailyTemperatures(self, temperatures: List[int]) -&gt; List[int]:     answer = [0 for _ in range(len(temperatures))]     for i in range(len(temperatures)):         for j in range(i+1,len(temperatures)):             if temperatures[j] &gt; temperatures[i]:                 answer[i] = j - i                 break     return answer\n\n单调栈(评论区解答)创建个栈，用来判断温度的高低，栈中存放的是元素的下标，遍历原数组，若此时遍历元素大于栈中的元素，则栈中元素出栈，并记录，再用当前元素下标值减去出栈元素的值，然后放入结果数组ans的相应位置，若小于的情况下直接入栈。具体代码如下:\nclass Solution: def dailyTemperatures(self, temperatures: List[int]) -&gt; List[int]:     stack = [] # 存放元素的下标值     res = [0 for _ in range(len(temperatures))] # 初始化结果数组     for i in range(len(temperatures)):         while stack and temperatures[i] &gt; temperatures[stack[-1]]:             tmp = stack.pop()             res[tmp] = i - tmp         stack.append(i)     return res\n\n503. 下一个更大元素 II\n单调栈由于给定的是循环数组，那么在进行查找下个更大元素时，可以定义一个新的数组new_nums其大小为nums + nums形成一个循环数组，然后在同样的定义一个栈，用来判断元素的大小，栈中的存入的元素为数组的下标值，小于入栈，大于出栈，再把相应的值赋值给结果数组ans即可。注意的是最后只返回ans数组的len(nums)大小，而不是返回新数组的长度大小。代码如下:\nclass Solution: def nextGreaterElements(self, nums: List[int]) -&gt; List[int]:     new_nums = nums + nums # 新数组     stack = []     ans = [-1 for _ in range(len(new_nums))] # 初始化结果数组     for i in range(len(new_nums)):         while stack and new_nums[i] &gt; new_nums[stack[-1]]: # 判断元素的大小             tmp = stack.pop()             ans[tmp] = new_nums[i] # 存放的元素为上一个最大的元素         stack.append(i)     return ans[0:len(nums)] # 注意返回的长度\n\n使用取余优化操作(评论区大神)再判断数组值的大小的时候用i%len(nums)来判断，就可以减少结果数组占用的空间，防止操作过程中，数组溢出。\nclass Solution: def nextGreaterElements(self, nums: List[int]) -&gt; List[int]:     N = len(nums)     res = [-1] * N # 初始化结果数组     stack = []     for i in range(N * 2):         while stack and nums[stack[-1]] &lt; nums[i%N]: # 这个取余没想到，刚好满足数组长度的大小，不会造成溢出             res[stack.pop()] = nums[i%N]         stack.append(i%N)     return res\n\n42.接雨水\n左右向最高点遍历(评论区大神思想)总体思路是先找出数列中最高点的值和位置，若有多个相同最高点任取其一即可，在定义变量left_max记录左边的最高点，从左开始向数列最高点处遍历，若当前值大于left_max则更新left_max若小于这储水量res&#x3D;left_max - height[i]。遍历完左边走再将left_max初始化为0，再从右边向最高点遍历，最后返回res\nclass Solution: def trap(self, height: List[int]) -&gt; int:     left_max = 0 # 左最高点     max_high = max(height) # 最高点     max_index = height.index(max_high) # 最高点下标     res = 0     # 从左向最高点遍历     for i in range(max_index):         if height[i] &gt;= left_max:             left_max = height[i] # 更新左最高         else:             res += left_max - height[i]     left_max = 0     # 从右向最搞点遍历     for j in range(len(height)-1,max_index,-1):         if height[j] &gt;= left_max:             left_max = height[j]         else:             res += left_max - height[j]     return res\n\n单调栈使用单调栈求解，横向求储水高度，首先定义栈stack并先存入第一个元素,(注意栈中存放的数组的下标值),再从第一号元素开始遍历数组，若小于或者等于栈中的元素则入栈，保持递增栈的状态，若大于则说明存在空隙，出栈并使用变量mid记录当前的栈顶元素，再比较当前元素与栈顶元素的大小，取最小的减去mid位置的值，得到雨水的高度，再使用当前变量i减去栈顶元素的值，再减一得到当前雨水的宽度，要再减一是因为只要计算空袭位置的宽度，将宽度乘以高度即为空隙处的储水量；再使用while循环遍历这个过程，当循环结束后要把当前i值入栈；用于后续的计算；\nclass Solution: def trap(self, height: List[int]) -&gt; int:     stack = [0] # 存放下标     res = 0 # 记录储水量     for i in range(1,len(height)):         # 递增栈         while stack and height[i] &gt; height[stack[-1]]:             mid = stack.pop()             if stack:                 h = min(height[i],height[stack[-1]]) - height[mid] # 计算高                 w = i - stack[-1] -1 # 计算宽                 res += h * w         stack.append(i)     return res\n\n145. 二叉树的后序遍历\n递归在函数内部定义一个新的函数postoder用来实现递归调用，并使用res数组记录每一次递归调用的值，完成后序遍历\n# Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    def postorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]:        res = []        def postorder(root):            # 判空            if not root:                return list()            # 递归后序遍历，左右根            postorder(root.left)            postorder(root.right)            res.append(root.val)        postorder(root)        return res\n\n迭代(知道原理写不出代码，菜！)借助辅助栈实现，首先先遍历到二叉树的左边第一个结点，并把从途经结点存入栈中，再判断当前结点是否存在右孩子或者是否已经遍历过，若不存在右孩子，则出栈记录该节点，并把当前root设置为None；若不为None则无法完成继续操作，因为当前结点出栈记录后，接着应该继续出栈结点，来判断改该节点的右孩子和遍历情况；若该节点有右孩子，则入栈并且将root指向它的右孩子，再接着判断其右孩子的左右孩子情况；依次迭代\n# Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    def postorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]:        if not root:            return list()        prev = None # 记录前驱        stack = []        res = []        while root or stack:            # 找到二叉树最左边的第一个元素            while root:                stack.append(root)                root=root.left            # 更新root的值            root=stack.pop()            # 判断改结点是否存在右子树或者是否已经遍历过            if not root.right or root.right==prev:                res.append(root.val)                prev = root # 记录遍历过的元素                root = None # 方便继续弹出栈元素进行判断处理            # 当前结点存在右子树            else:                stack.append(root)                root=root.right        return res\n\nMorris遍历(大概率以后又忘了…)一种巧妙的方法在O(n)时间复杂度和O(1)空间复杂度情况下完成二叉树遍历，由J. H. Morris 在 1979 年的论文「Traversing Binary Trees Simply and Cheaply」中首次提出。其具体思想就是利用树的空闲指针，实现其空间开销的极限缩减(类似于线索二叉树?),其规则具体如下:\n\n新建临时结点，root;\n如果当前结点左子为空，则遍历当前结点的右子节点；\n如果当前结点的左子节点不为空，在当前节点的左子树中找到当前节点在中序遍历下的前驱结点；\n如果前驱结点的右子节点为空，将前驱结点的右子节点设置为当前节点,当前节点更新为当前节点的左子节点。\n如果前驱节点的右子节点为当前节点，将它的右子节点重新设置为空。倒序输出从当前节点的左子节点到该前驱节点这条路径上的所有结点，当前结点更新为当前结点的右子节点。\n\n\n重复步骤2和3，直到遍历结束\n\n # Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    def postorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]:        def addpath(node:TreeNode):            count = 0            while node:                count += 1                res.append(node.val)                node = node.right            i,j = len(res) - count, len(res) - 1 # i,j 默认初始值为res的第一个和最后一个值            # 逆置res             while i&lt;j:                res[i],res[j] = res[j],res[i]                i += 1                j -= 1        if not root:            return list()        res = list()        p1 = root        # 类似线索化二叉树，记录结点在中序遍历中的前驱位置        while p1:            p2=p1.left            if p2:                # 找到p2的最右节点                while p2.right and p2.right!=p1:                    p2 = p2.right                # 若p2不存在右孩子了，则将p2的右指针指向p1，p1指向其左孩子，继续循环                if not p2.right:                    p2.right = p1                    p1 = p1.left                    continue                # p2 存在其右孩子 而且p2的右指针指向当前p1节点，那么将p2的右孩子重新置为空，利用addpath函数逆序记录当前节点的左子节点到其前驱节点的所有结点                else:                    p2.right = None                    addpath(p1.left)            # 更新当前结点指向其右子节点，在其右子节点重复上述操作            p1 = p1.right                # 剩下结点为将root到最右结点的路径，逆序记录到res，即可完成后序遍历        addpath(root)        return res\n\n104. 二叉树的最大深度\n动态规划 （参考以前提交的c++代码)定义left_depth和right_depth分别记录左右子树的深度，然后调用自身函数，返回左右子树深度最大的一个再加一(加上跟根节点的高度)\n# Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    def maxDepth(self, root: Optional[TreeNode]) -&gt; int:        if not root:            return 0        left_depth = self.maxDepth(root.left)        right_depth = self.maxDepth(root.right)        # 加一是因为还有根节点的高度        return max(left_depth,right_depth)+1\n\n广度优先搜索(LC官方题解)使用辅助队列queue将每一层的元素存入队列，在使用ans记录层数，sz记录每一层的个数，用while循环来判断，判断每一个结点是否有左右孩子，若有则入队，每判断一个元素，sz减一，当一层的元素全部判断完后，层数ans加一.\n# Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    def maxDepth(self, root: Optional[TreeNode]) -&gt; int:        if not root:            return 0        queue=[]        # 将根结点先入队，否则层数会少一层        queue.append(root)        ans = 0        while len(queue):            sz = len(queue) # 记录每一层的元素个数            # 判断每一个元素是否有左右孩子，有则入队            while sz&gt;0:                Node = queue.pop(0)                if Node.left:                    queue.append(Node.left)                if Node.right:                    queue.append(Node.right)                sz -= 1            # 每一层元素判断完毕后，层数加一            ans += 1        return ans\n\n","categories":["力扣"],"tags":["python","刷题"]},{"title":"计算机网络","url":"/2023/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","content":"计网概述因特网服务提供者ISP\n因特网的组成\n边缘部分 由所有连接在因特网上的主机组成，这部分是用户直接使用和资源共享\n核心部分 由大量网络和连接这些网络的路由器组成，这部分是为边缘部分提供服务的\n\n三种交换方式\n电路交换\n\n\n电话交换机接通电话线的方式\n电路交换的三个步骤\n建立连接 (分配通信资源)\n通话(一直占用资源)\n释放连接(归还通信资源)\n\n\n当使用电路交换来传送计算机数据时，线路的传输效率往往很低\n\n分组交换发送方:构造分组发送分组路由器:缓存分组转发分组接收方:接受分组还原报文报文交换与分组类似，主要用于早期的电报通信网，现在较少使用  \n三者对比三者优缺点电路交换:\n\n优点\n通信时延小\n有序传输\n没有冲突\n适用范围广\n实时性强\n控制简单\n\n\n缺点\n建立连接时间长\n线路独占，使用效率低\n灵活性差\n难以规格化\n\n\n\n报文交换:\n\n优点\n无需建立连接\n动态分配线路\n提高线路可靠性\n提高线路利用率\n提供多目标服务\n\n\n缺点\n引起转发时延\n需要较大存储缓存空间\n需要传输额外的信息量\n\n\n\n分组交换:\n\n优点\n无需建立连接\n线路利用率高\n简化了储存管理\n加速传输\n减少出错概率和重发数据量\n\n\n缺点\n引起转发时延\n需要传输额外的信息量\n对于数据服务，存在失序，丢失或重复分组的问题，对于虚电路服务，存在呼叫建立，数据传输和虚电路释放三个过程\n\n\n\n计算机网络分类按交换技术分类\n电路交换网络\n报文交换网络\n分组交换网络\n\n按使用者分\n公用网\n专用网\n\n按传输介质分类\n有线网络\n无线网络\n\n按覆盖范围分类\n广域网 WAN\n域域网 WAN\n局域网 LAN\n个域网 PAN\n\n按拓扑结构分类\n总线型网络\n星形网络\n环形网络\n网状型网络\n\n计算机网络的性能指标速率速率:是指在计算机网络上的主机在数字信道上传送比特的速率，也称为比特率或数据率比特:计算机中数据量的单位常用数据量单位常用数据率单位\n带宽带宽:(在计算机网络中的意义)用来表示网络的通信线路所能传送数据的能力。一条通信线路的频带宽度越宽，其所传输的最高数据率也越高单位:b/s(kb/s,Mb/s,Gb/s,Tb/s)\n吞吐量吞吐量：表示单位时间内通过某个网络的数据量吞吐量受网络带宽或额定速率的限制\n时延\n发送时延分组长度发送速率\n传播时延  信道长度电磁波传播速率电磁波传播速率:1.自由空间 3x10^8m/s 2.铜线 2.3x10^8m/s 3.光纤 2.0x10^8m/s\n处理时延一般不方便计算\n\n时延带宽积时延带宽积=传播时延X带宽\n往返时间 RTT\n利用率$$利用率=\\left{信道利用率表示某信道有百分之几的时间是利用的网络利用率全网络的信道利用率的加权平均\\right.$$\n丢包率丢包率是指在一定时间范围内，传输过程中丢失的分组数量与总分组数量的比率分组丢失主要有两种情况    1. 分组在传输过程中出现误码被结点丢弃    2. 分组到达一台队列已满的分组交换机时被丢弃；在通信量较大时就可能造成网络拥塞丢包率也反应了网络的拥塞情况\n\n无拥塞时路径丢包率为0\n轻度拥塞时路径丢包率为1%-4%\n严重拥塞时路劲丢包率为5%-15%\n\n","categories":["笔记"],"tags":["计算机网络"]}]